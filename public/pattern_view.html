<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Editor - Read Only Grouping</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>window.jsPDF = window.jspdf.jsPDF;</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F9F9F7;
            color: #2C3E50;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: 'Noto Serif JP', serif;
        }

        /* Read-only cell styling */
        .cell-read {
            background-color: transparent;
            width: 100%;
            height: 100%;
            padding: 8px;
            border: none;
            cursor: default;
        }

        .sticky-col {
            position: sticky;
            left: 0;
            z-index: 10;
            background-color: #FFFFFF;
        }

        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 20;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .btn-action {
            background-color: #4A5568;
            color: white;
            transition: all 0.2s;
        }

        .btn-action:hover {
            background-color: #2D3748;
        }

        .btn-primary {
            background-color: #C0392B;
            color: white;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            background-color: #A93226;
        }

        .btn-outline {
            background-color: #FFFFFF;
            border: 1px solid #E2E8F0;
            color: #4A5568;
            transition: all 0.2s;
        }

        .btn-outline:hover {
            background-color: #F7FAFC;
            border-color: #CBD5E0;
        }

        /* Japanese Art Watermark */
        .watermark {
            position: absolute;
            bottom: -50px;
            right: -50px;
            opacity: 0.15;
            pointer-events: none;
            z-index: 0;
            width: 400px;
            height: 400px;
        }
    </style>
</head>

<body class="h-screen flex flex-col overflow-hidden relative">

    <svg class="watermark" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <filter id="ink-blur" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.5" />
            </filter>
        </defs>
        <circle cx="220" cy="60" r="35" fill="#C0392B" opacity="0.8" style="mix-blend-mode: multiply;" />
        <g stroke="#2C3E50" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round" opacity="0.9">
            <path d="M260 300 Q270 200 240 100" stroke-width="4" />
            <path d="M220 300 Q230 250 210 180" stroke-width="2.5" />
        </g>
    </svg>

    <!-- Create Pattern Modal -->
    <div id="patternModal"
        class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm p-4">
        <div
            class="bg-white rounded-lg shadow-xl w-[95%] sm:w-full max-w-md flex flex-col overflow-hidden animate-in fade-in zoom-in duration-200">
            <div class="px-6 py-4 border-b border-[#E2E8F0] bg-[#F9F9F7]">
                <h3 class="font-bold text-[#2C3E50] text-lg">Create Pattern Group</h3>
            </div>
            <div class="p-6 space-y-4">
                <div>
                    <label class="block text-xs font-semibold text-[#7F8C8D] uppercase mb-1">Pattern Name</label>
                    <input type="text" id="newPatternName"
                        class="w-full border border-gray-300 rounded p-2 text-sm focus:border-blue-500 outline-none"
                        placeholder="e.g. Class 10 Boys Bundle">
                </div>
                <div class="bg-blue-50 p-3 rounded text-xs text-blue-800 border border-blue-100">
                    <p>Current Filters will be saved with this pattern.</p>
                    <p class="mt-1 font-bold">Students: <span id="patternCountDisplay">0</span></p>
                </div>
            </div>
            <div class="px-6 py-4 border-t border-[#E2E8F0] bg-[#F9F9F7] flex justify-end gap-3">
                <button onclick="document.getElementById('patternModal').classList.add('hidden')"
                    class="btn-outline px-4 py-2 rounded text-sm">Cancel</button>
                <button onclick="savePattern()" class="btn-primary px-6 py-2 rounded text-sm shadow-md">Create
                    Pattern</button>
            </div>
        </div>
    </div>


    <!-- Export Modal (Reused Logic) -->
    <div id="exportModal"
        class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm p-4">
        <div
            class="bg-white rounded-lg shadow-xl w-[95%] sm:w-full max-w-2xl max-h-[90vh] flex flex-col overflow-hidden animate-in fade-in zoom-in duration-200">
            <div class="px-6 py-4 border-b border-[#E2E8F0] bg-[#F9F9F7] flex justify-between items-center">
                <h3 class="font-bold text-[#2C3E50] text-lg">Export Pattern</h3>
                <button onclick="closeExportModal()" class="text-gray-400 hover:text-gray-600">Ã—</button>
            </div>
            <div class="p-6 space-y-4 overflow-y-auto">
                <div class="grid grid-cols-2 gap-4">
                    <div><label class="block text-xs uppercase text-gray-500">School Name</label><input type="text"
                            id="metaSchool" class="w-full border p-2 rounded text-sm"></div>
                    <div><label class="block text-xs uppercase text-gray-500">Pattern Code</label><input type="text"
                            id="metaPattern" class="w-full border p-2 rounded text-sm"></div>
                </div>
                <div><label class="block text-xs uppercase text-gray-500">Description</label><textarea id="metaDesc"
                        rows="2" class="w-full border p-2 rounded text-sm"></textarea></div>

                <div class="bg-[#F0F4F8] p-4 rounded-md border border-[#CBD5E0]">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-xs font-bold uppercase">Cloth Consumption (M/Student)</label>
                        <input type="number" id="metaConsumption" step="0.01" class="w-32 border p-1 rounded text-right"
                            placeholder="0.00" oninput="updateExportTotal()">
                    </div>
                    <div class="flex justify-between text-xs text-gray-500 pt-2 border-t border-gray-300">
                        <span>Total Cloth Needed:</span>
                        <span id="exportTotalCloth" class="font-bold text-lg text-gray-800">0.00 M</span>
                    </div>
                </div>

                <!-- Additional Metadata Fields -->
                <div>
                    <label class="block text-xs uppercase text-gray-500">Cloth Details</label>
                    <textarea id="metaClothDetails" rows="2" class="w-full border p-2 rounded text-sm"
                        placeholder="e.g. Cotton 100%"></textarea>
                </div>
                <div>
                    <label class="block text-xs uppercase text-gray-500">Special Requirements</label>
                    <textarea id="metaSpecialReq" rows="2" class="w-full border p-2 rounded text-sm"
                        placeholder="Any special instructions..."></textarea>
                </div>

                <!-- Item Summary Display (Dynamic) -->
                <div>
                    <label class="block text-xs uppercase text-gray-500 mb-1">Item Quantity Breakdown</label>
                    <div id="exportItemSummary" class="flex flex-wrap gap-2">
                        <!-- Items injected by JS -->
                    </div>
                </div>

                <div class="text-xs text-gray-500 bg-gray-50 p-2 rounded border border-gray-200">
                    <strong>Filters in this Pattern:</strong> <span id="exportFilters" class="italic"></span>
                </div>
            </div>
            <div class="px-6 py-4 border-t bg-[#F9F9F7] flex justify-end gap-3">
                <button onclick="savePatternMetadata()"
                    class="btn-action bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm text-white shadow-sm flex items-center gap-1">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    Save Details
                </button>
                <div class="w-px h-6 bg-gray-300 mx-1"></div>
                <button onclick="confirmExportPDF()"
                    class="btn-outline px-4 py-2 rounded text-sm text-red-600 border-red-200 hover:bg-red-50">Export
                    PDF</button>
                <button onclick="confirmExport()" class="btn-action px-6 py-2 rounded text-sm">Export Excel</button>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header
        class="bg-white border-b border-[#E2E8F0] px-4 sm:px-6 py-4 flex flex-col lg:flex-row justify-between items-center shadow-sm z-30 relative gap-4">
        <div class="flex items-center gap-4 w-full lg:w-auto justify-center lg:justify-start">
            <div class="bg-gradient-to-br from-[#C0392B] to-[#922B21] text-white p-2 rounded-md shadow-sm shrink-0">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <path d="M14 2v6h6"></path>
                    <path d="M16 13H8"></path>
                    <path d="M16 17H8"></path>
                    <path d="M10 9H8"></path>
                </svg>
            </div>
            <div>
                <h1 class="text-2xl font-serif text-[#2D3748] tracking-tight">Pattern Dashboard</h1>
                <p class="text-xs text-[#7F8C8D] tracking-wide">READ-ONLY GROUPING SYSTEM</p>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row items-center gap-3 w-full lg:w-auto justify-center lg:justify-end">
            <div class="flex items-center gap-3 order-2 sm:order-1 mr-4">
                <a href="planet_editor.html"
                    class="text-xs font-bold text-gray-500 hover:text-gray-800 uppercase tracking-wide">
                    &larr; Editor
                </a>
                <span class="text-gray-300">|</span>
                <a href="packing_dashboard.html"
                    class="text-xs font-bold text-gray-500 hover:text-gray-800 uppercase tracking-wide">
                    Packing
                </a>
            </div>
            <button onclick="loadFromCloud()"
                class="mr-2 text-xs font-bold text-blue-500 hover:text-blue-700 uppercase tracking-wide">
                Refresh Cloud Data
            </button>
            <button onclick="openLogs()"
                class="mr-2 text-xs font-bold text-indigo-500 hover:text-indigo-700 uppercase tracking-wide flex items-center gap-1">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
                Logs
            </button>
            <input type="file" id="fileInput" accept=".xlsx, .xls" class="hidden" onchange="handleFileUpload(event)" />

            <div class="flex gap-2 order-1 sm:order-2 w-full sm:w-auto justify-center">
                <button onclick="clearData()"
                    class="btn-outline px-4 py-2 rounded-md text-sm font-medium text-red-600 border-red-200 hover:bg-red-50 flex items-center gap-2"
                    title="Clear saved data">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6" />
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                    </svg>
                    Clear Data
                </button>
                <button onclick="document.getElementById('fileInput').click()"
                    class="btn-outline px-4 py-2 rounded-md text-sm font-medium flex items-center gap-2">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Import Excel
                </button>
            </div>
    </header>

    <!-- Pattern List & Toolbar -->
    <div
        class="bg-[#F8F9FA] border-b border-[#E2E8F0] px-6 py-2 flex items-center gap-4 overflow-x-auto whitespace-nowrap">
        <span class="text-xs font-bold text-gray-400 uppercase tracking-wider">Saved Patterns:</span>
        <div id="patternList" class="flex gap-2">
            <!-- Patterns inserted here -->
            <span class="text-xs text-gray-400 italic py-1">No patterns created yet.</span>
        </div>
    </div>

    <!-- Filters Toolbar -->
    <div
        class="bg-white border-b border-[#E2E8F0] px-4 sm:px-6 py-3 flex flex-col xl:flex-row items-center gap-4 overflow-x-auto z-20">
        <div
            class="flex flex-col sm:flex-row flex-wrap items-center gap-3 w-full xl:w-auto justify-center sm:justify-start">
            <div class="relative w-full sm:w-auto">
                <svg class="absolute left-3 top-2 text-[#A0AEC0]" width="16" height="16" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                <input type="text" id="searchInput" oninput="handleSearch()" placeholder="Search..."
                    class="pl-9 pr-3 py-1.5 text-sm border border-[#E2E8F0] rounded-md focus:border-[#4A5568] w-full sm:w-32 bg-[#F9F9F7]">
            </div>

            <div class="flex flex-wrap gap-2 w-full sm:w-auto justify-center sm:justify-start">
                <select id="filterClass" onchange="handleFilter()"
                    class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 flex-1 sm:flex-none">
                    <option value="">All Classes</option>
                </select>
                <select id="filterSection" onchange="handleFilter()"
                    class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 flex-1 sm:flex-none">
                    <option value="">All Sections</option>
                </select>
                <select id="filterHouse" onchange="handleFilter()"
                    class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 flex-1 sm:flex-none">
                    <option value="">All Houses</option>
                </select>
                <select id="filterGender" onchange="handleFilter()"
                    class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 flex-1 sm:flex-none">
                    <option value="">All Genders</option>
                </select>
            </div>

            <div class="h-px w-full sm:h-6 sm:w-px bg-gray-300 mx-2 hidden sm:block"></div>

            <select id="filterItem" onchange="handleItemFilter()"
                class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 outline-none focus:border-[#4A5568] w-full sm:w-auto max-w-none sm:max-w-[150px]">
                <option value="">Filter by Item</option>
            </select>

            <!-- Dynamic Range Filters -->
            <div id="dynamicFilters"
                class="flex flex-wrap items-center gap-2 justify-center sm:justify-start w-full sm:w-auto"></div>

            <div class="h-px w-full sm:h-6 sm:w-px bg-gray-300 mx-2 hidden sm:block"></div>

            <div class="flex gap-2 w-full sm:w-auto justify-center sm:justify-start">
                <button onclick="resetView()"
                    class="text-gray-500 hover:text-gray-800 text-xs font-bold uppercase mx-2 whitespace-nowrap"
                    title="Clear all filters to create new pattern">
                    Reset / New
                </button>

                <button id="btnCreatePattern" onclick="openPatternModal()"
                    class="bg-[#2D3748] text-white px-4 py-1.5 rounded-md text-sm font-bold shadow hover:bg-[#1A202C] flex items-center gap-2 whitespace-nowrap">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 5v14"></path>
                        <path d="M5 12h14"></path>
                    </svg>
                    Create Pattern
                </button>

                <button id="btnUpdatePattern" onclick="updatePattern()"
                    class="bg-blue-600 text-white px-4 py-1.5 rounded-md text-sm font-bold shadow hover:bg-blue-700 flex items-center gap-2 hidden whitespace-nowrap">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                        <polyline points="17 21 17 13 7 13 7 21" />
                        <polyline points="7 3 7 8 15 8" />
                    </svg>
                    Update Pattern
                </button>
            </div>
        </div>

        <div class="text-xs text-gray-500 ml-auto w-full xl:w-auto text-center xl:text-right mt-2 xl:mt-0">
            Showing <span id="rowCount" class="font-bold text-gray-800">0</span> Records
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex-1 overflow-auto relative bg-[#F9F9F7]/90 z-10 flex flex-col">
        <div id="tableView" class="flex-1 overflow-auto">
            <table class="w-full border-collapse text-sm">
                <thead id="tableHead"
                    class="bg-white text-gray-500 font-medium text-xs uppercase sticky-header shadow-sm"></thead>
                <tbody id="tableBody" class="bg-white/80 backdrop-blur-sm"></tbody>
            </table>
        </div>
    </main>

    <script>
        let data = [];
        let patterns = [];
        let currentWorkbook = null;
        let loadedPatternId = null;

        let filters = { search: '', class: '', section: '', house: '', gender: '', item: '', components: {} };

        // Persistence Keys
        const STORAGE_KEY_DATA = 'pattern_dashboard_data';
        const STORAGE_KEY_PATTERNS = 'pattern_dashboard_patterns';

        // --- PERSISTENCE ---
        function saveToLocal() {
            try {
                localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(data));
                localStorage.setItem(STORAGE_KEY_PATTERNS, JSON.stringify(patterns));
            } catch (e) {
                console.warn("Storage full or disabled", e);
            }
        }

        function loadFromLocal() {
            try {
                const sData = localStorage.getItem(STORAGE_KEY_DATA);
                const sPatterns = localStorage.getItem(STORAGE_KEY_PATTERNS);
                if (sData) {
                    data = JSON.parse(sData);
                    populateFilters();
                    renderTable();
                    updateCount();
                }
                if (sPatterns) {
                    patterns = JSON.parse(sPatterns);
                    renderModules();
                }
            } catch (e) { console.error(e); }
        }

        function clearData() {
            if (confirm("Are you sure you want to clear all data and patterns? This cannot be undone.")) {
                localStorage.removeItem(STORAGE_KEY_DATA);
                localStorage.removeItem(STORAGE_KEY_PATTERNS);
                location.reload();
            }
        }

        // Load on Init
        window.addEventListener('DOMContentLoaded', () => {
            // loadFromLocal(); // Legacy
            loadFromCloud();
        });

        async function loadFromCloud() {
            const token = sessionStorage.getItem('token');
            const schoolId = sessionStorage.getItem('schoolId'); // Or derived from user

            if (!token) {
                console.warn("No token, loading local");
                loadFromLocal();
                return;
            }

            try {
                // 1. Fetch Students (Global School Data)
                const resS = await fetch(`/api/data/students/${schoolId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (resS.ok) {
                    const cloudStudents = await resS.json();
                    data = cloudStudents.map((s, i) => {
                        // Map DB Student to Dashboard Row Format
                        const row = {
                            "id": s.id, // Primary Key for Linking
                            "S.No": i + 1,
                            "Roll No": s.roll_no || "",
                            "Admission No": s.admission_no || "",
                            "Student Name": s.name || "",
                            "Class": s.class || "",
                            "Section": s.section || "",
                            "House": s.house || "",
                            "Gender": s.gender || "",
                            "Absent/Present": (s.measurements && s.is_absent) ? "Absent" : "Present"
                        };
                        if (s.measurements) {
                            measureCols.forEach(col => row[col] = s.measurements[col] || "00");
                        } else {
                            measureCols.forEach(col => row[col] = "00");
                        }
                        // Quantities
                        if (s.item_quantities) {
                            Object.keys(s.item_quantities).forEach(key => row[key] = s.item_quantities[key]);
                        }
                        return row;
                    });

                    updateCount();
                    populateFilters();
                    renderTable();
                }

                // 2. Fetch Patterns
                const resP = await fetch(`/api/data/patterns/${schoolId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (resP.ok) {
                    const cloudPatterns = await resP.json();

                    // MAP to store quantities by Admission No (Unique key)
                    const qtyMap = {};

                    // Map DB Patterns to Local Format
                    patterns = cloudPatterns.map(cp => {
                        let parsedSpecial = {};
                        try { parsedSpecial = JSON.parse(cp.special_req || '{}'); } catch (e) { }

                        let filters = {};
                        let notes = "";
                        let itemSummary = [];

                        // Handle Legacy vs New Format
                        if (parsedSpecial.filters) {
                            filters = parsedSpecial.filters;
                            notes = parsedSpecial.notes || "";
                            itemSummary = parsedSpecial.item_summary || [];
                        } else {
                            // Assume Legacy (Direct Filters)
                            filters = parsedSpecial;
                        }

                        let parsedQty = [];
                        try { parsedQty = JSON.parse(cp.quantities || '[]'); } catch (e) { }

                        // Merge Quantities into Map
                        if (Array.isArray(parsedQty)) {
                            parsedQty.forEach(pq => {
                                // pq = { admission_no: "...", name: "...", quantities: { "Qty_Shirt": 2 } }
                                // Map by Admission No
                                if (pq.admission_no && pq.quantities) {
                                    qtyMap[pq.admission_no] = pq.quantities;
                                }
                            });
                        }

                        return {
                            id: cp.id,
                            name: cp.name,
                            description: cp.description || "",
                            consumption: cp.consumption || 0,
                            cloth_details: cp.cloth_details || "",
                            filters: filters,
                            notes: notes,
                            saved_item_summary: itemSummary,
                            count: Array.isArray(parsedQty) ? parsedQty.length : 0
                        };
                    });

                    // 3. MERGE Quantities into Main Data Array
                    // This ensures "created pattern contains data" when loaded
                    data = data.map(row => {
                        const admNo = row['Admission No'];
                        if (qtyMap[admNo]) {
                            return { ...row, ...qtyMap[admNo] }; // Overwrite with saved values
                        }
                        return row;
                    });

                    renderModules();
                    renderTable(); // Re-render table with new quantities
                }

            } catch (e) {
                console.error("Cloud Error", e);
                loadFromLocal();
            }
        }

        // Constants
        const infoCols = ["S.No", "Roll No", "Admission No", "Student Name", "Class", "Section", "House", "Gender", "Absent/Present"];
        const measureCols = ["U1", "U2", "U3", "U4", "U5", "U6", "U7", "U8", "L1", "L2", "L3", "L4", "L5", "L6", "L7", "L8"];

        // Item Definitions
        const boysItems = [
            { name: "BOYS - FORMAL SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Male" },
            { name: "BOYS - TRACK T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Male" },
            { name: "BOYS - UNIFORM T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Male" },
            { name: "BOYS - JERKIN", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Male" },
            { name: "BOYS - PULLOVER", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Male" },
            { name: "BOYS - FORMAL PANT", cols: ["L1", "L2"], type: "Male" },
            { name: "BOYS - TRACK PANT", cols: ["L1", "L2"], type: "Male" },
            { name: "BOYS - FORMAL SHORTS", cols: ["L3", "L2"], type: "Male" },
            { name: "BOYS - TRACK SHORTS", cols: ["L3", "L2"], type: "Male" },
            { name: "BOYS - PANT SPECIAL CASE", cols: ["L1", "L2", "L6", "L7"], type: "Male" },
        ];
        const girlsItems = [
            { name: "GIRLS - FORMAL SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - TRACK T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - UNIFORM T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - JERKIN", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Female" },
            { name: "GIRLS - FULL SLEEVE SHIRT", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Female" },
            { name: "GIRLS - PULLOVER", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Female" },
            { name: "GIRLS - KURTHA SHIRT", cols: ["U7", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - SPECIAL FROCKS", cols: ["U7", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - FORMAL PANT", cols: ["L1", "L2"], type: "Female" },
            { name: "GIRLS - TRACK PANT", cols: ["L1", "L2"], type: "Female" },
            { name: "GIRLS - TRACK SHORTS", cols: ["L3", "L2"], type: "Female" },
            { name: "GIRLS - PINOFORE", cols: ["L4", "L2"], type: "Female" },
            { name: "GIRLS - SKIRT", cols: ["L5", "L2"], type: "Female" },
            { name: "GIRLS - PANT SPECIAL CASE", cols: ["L1", "L2", "L6", "L7"], type: "Female" },
        ];
        const allItems = [...boysItems, ...girlsItems];

        // --- CORE FUNCTIONS ---

        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const ab = await file.arrayBuffer();
            currentWorkbook = XLSX.read(ab);
            const ws = currentWorkbook.Sheets[currentWorkbook.SheetNames[0]];

            let headerRowIndex = 0;
            const rawRows = XLSX.utils.sheet_to_json(ws, { header: 1 });
            for (let i = 0; i < Math.min(rawRows.length, 20); i++) {
                const rowStr = JSON.stringify(rawRows[i] || []).toLowerCase();
                if (rowStr.includes("student") && rowStr.includes("name")) { headerRowIndex = i; break; }
            }

            const jsonData = XLSX.utils.sheet_to_json(ws, { range: headerRowIndex, defval: "" });

            // RELIABLE IMPORT (Array Mode) to fix Quantity Mapping
            const headerRow = rawRows[headerRowIndex];
            const dataRows = rawRows.slice(headerRowIndex + 1);

            data = dataRows.map((rArr, i) => {
                const newRow = {};
                // fill info/measures
                infoCols.forEach(col => {
                    const idx = headerRow.findIndex(h => h && h.toString().trim().toLowerCase() === col.toLowerCase());
                    if (idx !== -1) newRow[col] = rArr[idx];
                });
                measureCols.forEach(col => {
                    const idx = headerRow.findIndex(h => h && h.toString().startsWith(col));
                    if (idx !== -1) newRow[col] = rArr[idx] || "00";
                    else newRow[col] = "00";
                });

                // Fill Quantities by Header Position - Robust Logic
                allItems.forEach(item => {
                    const itemIdx = headerRow.indexOf(item.name);
                    if (itemIdx !== -1) {
                        // Assume Qty is next
                        const nextCol = headerRow[itemIdx + 1];
                        if (nextCol && (nextCol.toString().toLowerCase().includes("qty") || nextCol.toString().toLowerCase().includes("quantity"))) {
                            newRow[`Qty_${item.name}`] = rArr[itemIdx + 1];
                        }
                    }
                });

                if (!newRow["S.No"]) newRow["S.No"] = i + 1;
                return newRow;
            });

            populateFilters();

            // Auto-Detect Item Logic
            // If the uploaded file contains a column header matching an item name, auto-select it.
            let detectedItem = null;
            if (headerRow) {
                for (const item of allItems) {
                    if (headerRow.some(h => h && h.toString().trim() === item.name)) {
                        detectedItem = item.name;
                        break; // Prioritize the first one found
                    }
                }
            }

            if (detectedItem) {
                document.getElementById('filterItem').value = detectedItem;
                handleItemFilter(); // This handles rendering
                // Also trigger basic filter update to ensure state consistency
                // handleFilter(); 
            } else {
                renderTable();
                updateCount();
            }
            saveToLocal(); // Save new data
        }

        function populateFilters() {
            const getOpts = (key) => [...new Set(data.map(r => r[key]).filter(Boolean))].sort();
            const updateSelect = (id, opts, label) => {
                const el = document.getElementById(id);
                // Preserve value if possible, but usually we reset on new file
                const currentVal = el.value;
                el.innerHTML = `<option value="">${label}</option>` + opts.map(o => `<option value="${o}">${o}</option>`).join('');
                if (opts.includes(currentVal)) el.value = currentVal;
            };

            updateSelect('filterClass', getOpts('Class'), 'All Classes');
            updateSelect('filterSection', getOpts('Section'), 'All Sections');
            updateSelect('filterHouse', getOpts('House'), 'All Houses');
            updateSelect('filterGender', getOpts('Gender'), 'All Genders');

            const itemSelect = document.getElementById('filterItem');
            // We want to keep the list of ALL items, not just present ones?
            // Actually, showing only present items might be better UX?
            // "pattern dashboard" should allow filtering by any known item type to create new patterns?
            // No, stick to allItems as defined constantly.
            itemSelect.innerHTML = '<option value="">Filter by Item</option>' + allItems.map(i => `<option value="${i.name}">${i.name}</option>`).join('');
        }

        function handleFilter() {
            filters.class = document.getElementById('filterClass').value;
            filters.section = document.getElementById('filterSection').value;
            filters.house = document.getElementById('filterHouse').value;
            filters.gender = document.getElementById('filterGender').value;
            renderTable();
            updateCount();
        }

        function handleItemFilter() {
            const itemName = document.getElementById('filterItem').value;
            filters.item = itemName;
            filters.components = {};
            const container = document.getElementById('dynamicFilters');
            container.innerHTML = '';

            if (itemName) {
                const item = allItems.find(i => i.name === itemName);
                if (item) {
                    item.cols.forEach(col => {
                        const values = [...new Set(data.map(r => r[col]).filter(v => v && v !== "00"))].sort();

                        const wrapper = document.createElement('div');
                        wrapper.className = "relative inline-block";

                        const input = document.createElement('input');
                        input.setAttribute('list', `list-${col}`);
                        input.type = "text";
                        input.placeholder = col;
                        input.className = "text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 outline-none focus:border-[#4A5568] w-20 text-gray-600";

                        const dl = document.createElement('datalist');
                        dl.id = `list-${col}`;
                        dl.innerHTML = values.map(v => `<option value="${v}">`).join('');

                        input.onchange = (e) => {
                            if (e.target.value) filters.components[col] = e.target.value;
                            else delete filters.components[col];
                            renderTable();
                            updateCount();
                        };

                        wrapper.appendChild(input);
                        wrapper.appendChild(dl);
                        container.appendChild(wrapper);
                    });
                }
            }
            renderTable();
            updateCount();
        }

        function handleSearch() {
            filters.search = document.getElementById('searchInput').value.toLowerCase();
            renderTable();
            updateCount();
        }

        function getFilteredData() {
            return data.filter(row => {
                // 1. Basic Filters
                const matchSearch = !filters.search || Object.values(row).some(v => String(v).toLowerCase().includes(filters.search));
                const matchClass = !filters.class || row.Class == filters.class;
                const matchSection = !filters.section || row.Section == filters.section;
                const matchHouse = !filters.house || row.House == filters.house;
                const matchGender = !filters.gender || row.Gender == filters.gender;

                // 2. Item Gender Logic
                let matchItem = true;
                if (filters.item) {
                    const item = allItems.find(i => i.name === filters.item);
                    if (item) {
                        const gender = (row.Gender || "").toUpperCase();
                        if (item.type === "Male" && gender !== "MALE") matchItem = false;
                        if (item.type === "Female" && gender !== "FEMALE") matchItem = false;
                    }
                }

                // 3. Component Range Logic (The "Advanced" part)
                let matchComp = true;
                if (filters.item) {
                    Object.keys(filters.components).forEach(col => {
                        const filterVal = filters.components[col];
                        const rowVal = row[col];
                        // Range e.g. "30-32"
                        if (filterVal.includes('-')) {
                            const [min, max] = filterVal.split('-').map(Number);
                            if (!isNaN(min) && !isNaN(max)) {
                                const valNum = parseFloat(rowVal);
                                if (isNaN(valNum) || valNum < min || valNum > max) matchComp = false;
                            } else {
                                if (String(rowVal) !== filterVal) matchComp = false; // fallback
                            }
                        } else {
                            if (String(rowVal) !== filterVal) matchComp = false;
                        }
                    });
                }

                return matchSearch && matchClass && matchSection && matchHouse && matchGender && matchItem && matchComp;
            });
        }

        function calculateItemValue(row, item) {
            const parts = item.cols.map(col => {
                const v = row[col];
                return (v && v !== '00') ? v : "00";
            });
            return parts.join(",");
        }

        function renderTable() {
            const filtered = getFilteredData();
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');

            // Header
            let h = `<tr class="bg-[#F7FAFC]">
                <th class="p-3 border-b border-r min-w-[50px] text-center font-bold text-gray-600">#</th>
                <th class="p-3 border-b border-r min-w-[200px] text-left font-bold text-gray-600 sticky-col z-20">Student Name</th>
                <th class="p-3 border-b border-r min-w-[80px]">Class</th>
                <th class="p-3 border-b border-r min-w-[80px]">Sec</th>
                <th class="p-3 border-b border-r min-w-[80px]">Gender</th>
                <th class="p-3 border-b border-r min-w-[100px]">Adm No</th>`;

            measureCols.forEach(c => {
                const color = c.startsWith('U') ? 'text-blue-600 bg-blue-50' : 'text-green-600 bg-green-50';
                h += `<th class="p-2 border-b border-r ${color} text-center text-xs font-mono">${c}</th>`;
            });
            // Add Item Columns if Filtered
            const activeItemName = document.getElementById('filterItem') ? document.getElementById('filterItem').value : null;
            if (activeItemName) {
                h += `<th class="p-3 border-b border-r bg-purple-50 text-purple-700 font-bold min-w-[150px] sticky-col z-20" style="left: 200px;">${activeItemName}</th>`;
                h += `<th class="p-3 border-b border-r bg-yellow-50 text-yellow-700 font-bold min-w-[80px]">Qty</th>`;
            }

            h += `</tr>`;
            thead.innerHTML = h;

            // Body
            tbody.innerHTML = filtered.map((row, i) => {
                let r = `<tr class="hover:bg-gray-50 border-b border-gray-100">
                    <td class="p-2 border-r text-center text-xs text-gray-400 font-mono">${row["S.No"]}</td>
                    <td class="p-2 border-r font-medium text-gray-700 sticky-col bg-white">${row["Student Name"]}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs">${row["Class"]}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs">${row["Section"]}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs">${row["Gender"]}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs text-mono">${row["Admission No"]}</td>`;

                measureCols.forEach(c => {
                    let val = row[c];
                    if (val === '00' || val === '0') val = '';
                    r += `<td class="p-2 border-r text-center font-mono text-gray-600 text-sm">${val}</td>`;
                });
                if (activeItemName) {
                    const item = allItems.find(i => i.name === activeItemName);
                    if (item) {
                        const calcVal = calculateItemValue(row, item);
                        const qty = row[`Qty_${item.name}`] || "";
                        r += `<td class="p-2 border-r text-center text-xs text-purple-700 font-mono bg-purple-50/30 font-bold">${calcVal}</td>`;
                        r += `<td class="p-2 border-r text-center text-sm font-bold text-yellow-700 bg-yellow-50/30">${qty}</td>`;
                    }
                }

                r += `</tr>`;
                return r;
            }).join('');
        }

        function updateCount() {
            const count = getFilteredData().length;
            document.getElementById('rowCount').textContent = count;
            document.getElementById('patternCountDisplay').textContent = count;
        }

        // --- PATTERN LOGIC ---

        function openPatternModal() {
            if (getFilteredData().length === 0) {
                alert("No data to group! Import a file or adjust filters.");
                return;
            }
            document.getElementById('newPatternName').value = `Pattern ${patterns.length + 1}`;
            updateCount();
            document.getElementById('patternModal').classList.remove('hidden');
        }

        async function savePattern() {
            const name = document.getElementById('newPatternName').value;
            if (!name) return alert("Enter a pattern name");

            // Get currently filtered students
            const currentData = getFilteredData();

            // 1. Calculate Aggregate Consumption (Total of all Qty fields for all students)
            // And 2. Prepare Per-Student Quantity Snapshot & IDs
            let totalConsumption = 0;
            const studentIds = [];

            const studentQuantities = currentData.map(student => {
                if (student.id) studentIds.push(student.id);

                // Extract only Qty_ fields
                const qties = {};
                Object.keys(student).forEach(k => {
                    if (k.startsWith("Qty_")) {
                        qties[k] = parseFloat(student[k]) || 0;
                        totalConsumption += qties[k];
                    }
                });
                return {
                    admission_no: student['Admission No'],
                    name: student['Student Name'],
                    quantities: qties
                };
            });

            // Metadata
            const description = `Pattern Group with ${currentData.length} students`;
            const cloth_details = "N/A"; // Could be input later

            const payload = {
                school_id: sessionStorage.getItem('schoolId'),
                name: name,
                description: description,
                consumption: parseFloat(totalConsumption.toFixed(2)), // Aggregate total
                cloth_details: cloth_details,
                special_req: JSON.stringify({ filters: filters, notes: "", item_summary: [] }), // New Structure
                quantities: studentQuantities, // Save detailed calculated snapshot
                student_ids: studentIds // Link students to this pattern
            };

            try {
                const token = sessionStorage.getItem('token');
                if (!token) throw new Error("Offline - Please Log In");

                const res = await fetch('/api/data/patterns', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                    body: JSON.stringify(payload)
                });

                if (res.ok) {
                    alert("Pattern Saved to Cloud!");
                    if (window.Logger) window.Logger.log('CREATE_PATTERN', `Created pattern: ${name}`);
                    document.getElementById('patternModal').classList.add('hidden');
                    loadFromCloud();
                } else {
                    const err = await res.text();
                    alert(`Failed to save (Server ${res.status}): ${err}`);
                }
            } catch (e) {
                console.error(e);
                alert("Save Failed: " + e.message);
            }
        }
        // Auto-load the new pattern to allow immediate editing? 
        // Better to stay in "Create" mode or switch? 
        // Let's just reset view to prompt user to start fresh OR keep filters?
        // Standard: keep filters, but user might want to reset.


        async function updatePattern() {
            if (!loadedPatternId) return;
            const pIndex = patterns.findIndex(p => p.id === loadedPatternId);
            if (pIndex === -1) return;

            const name = patterns[pIndex].name; // Keep existing name or ask? 
            // For now, assume name doesn't change on update, only content. 
            // If name change is needed, we need a prompt or input.
            // Let's stick to content update for now.

            if (!confirm(`Update pattern "${name}" with current filters and calculated quantities?`)) return;

            // --- Payload Construction (Duplicated from savePattern for safety) ---
            const currentData = getFilteredData();
            let totalConsumption = 0;
            const studentIds = [];
            const studentQuantities = currentData.map(student => {
                if (student.id) studentIds.push(student.id);
                const qties = {};
                Object.keys(student).forEach(k => {
                    if (k.startsWith("Qty_")) {
                        qties[k] = parseFloat(student[k]) || 0;
                        totalConsumption += qties[k];
                    }
                });
                return {
                    admission_no: student['Admission No'],
                    name: student['Student Name'],
                    quantities: qties
                };
            });

            const payload = {
                school_id: sessionStorage.getItem('schoolId'),
                name: name,
                description: `Updated Pattern Group (${currentData.length} students)`,
                consumption: parseFloat(totalConsumption.toFixed(2)),
                cloth_details: "N/A",
                special_req: JSON.stringify(filters),
                quantities: studentQuantities,
                student_ids: studentIds
            };

            try {
                const token = sessionStorage.getItem('token');
                if (!token) throw new Error("Offline - Please Log In");

                const res = await fetch(`/api/data/patterns/${loadedPatternId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                    body: JSON.stringify(payload)
                });

                if (res.status === 401 || res.status === 403) {
                    throw new Error("Session Expired - Please Log In Again");
                }

                if (res.ok) {
                    alert("Pattern Updated Successfully!");
                    if (window.Logger) window.Logger.log('UPDATE_PATTERN', `Updated pattern: ${name}`);
                    loadFromCloud(); // Reload to get fresh state
                    resetView(); // Exit update mode
                } else {
                    const err = await res.text();
                    alert(`Failed to update (Server ${res.status}): ${err}`);
                }
            } catch (e) {
                console.error(e);
                alert("Update Failed: " + e.message);
            }
        }

        function renderModules() {
            const container = document.getElementById('patternList');
            if (patterns.length === 0) {
                container.innerHTML = '<span class="text-xs text-gray-400 italic py-1">No patterns created yet.</span>';
                return;
            }

            container.innerHTML = patterns.map(p => `
                <div class="flex items-center gap-2 bg-white border border-gray-200 rounded-md px-3 py-1 text-sm shadow-sm group">
                    <button onclick="loadPattern(${p.id})" class="text-blue-600 font-bold hover:underline" title="Load Filters">${p.name}</button>
                    <span class="text-xs text-gray-400 font-mono">(${p.count})</span>
                    <button onclick="openExportForPattern(${p.id})" class="text-gray-400 hover:text-green-600 ml-1" title="Export Pattern">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    </button>
                    <button onclick="deletePattern(${p.id})" class="text-gray-300 hover:text-red-500 ml-1 opacity-0 group-hover:opacity-100 transition-opacity">Ã—</button>
                </div>
            `).join('');
        }

        function loadPattern(id) {
            const p = patterns.find(x => x.id === id);
            if (!p) return;

            filters = JSON.parse(JSON.stringify(p.filters));

            // Restore Inputs
            document.getElementById('searchInput').value = filters.search;
            document.getElementById('filterClass').value = filters.class;
            document.getElementById('filterSection').value = filters.section;
            document.getElementById('filterHouse').value = filters.house;
            document.getElementById('filterGender').value = filters.gender;

            // Restore Item Filters & Datalists
            document.getElementById('filterItem').value = filters.item;

            // Re-trigger item filter rendering to show dyanmic controls
            handleItemFilter();

            // Now restore the dynamic component values
            const container = document.getElementById('dynamicFilters');
            if (filters.components) {
                Array.from(container.children).forEach(wrapper => {
                    const input = wrapper.querySelector('input');
                    if (input && filters.components[input.placeholder]) {
                        input.value = filters.components[input.placeholder];
                    }
                });
            }

            renderTable();
            updateCount();
            alert(`Loaded pattern: ${p.name}`);

            // Enter "Update Mode"
            loadedPatternId = p.id;
            document.getElementById('btnCreatePattern').classList.add('hidden');
            document.getElementById('btnUpdatePattern').classList.remove('hidden');
        }

        function resetView() {
            // Clear Filters
            document.getElementById('searchInput').value = '';
            document.getElementById('filterClass').value = '';
            document.getElementById('filterSection').value = '';
            document.getElementById('filterHouse').value = '';
            document.getElementById('filterGender').value = '';
            document.getElementById('filterItem').value = '';

            // Clear internal state
            filters = { search: '', class: '', section: '', house: '', gender: '', item: '', components: {} };

            // Re-render
            handleItemFilter(); // Clears dynamic
            // handleFilter() called internally? no, manual reset
            renderTable();
            updateCount();

            // Reset Mode
            loadedPatternId = null;
            document.getElementById('btnCreatePattern').classList.remove('hidden');
            document.getElementById('btnUpdatePattern').classList.add('hidden');
        }

        async function deletePattern(id) {
            if (!confirm("Are you sure you want to permanently delete this pattern group?")) return;

            try {
                const token = sessionStorage.getItem('token');
                if (!token) throw new Error("Offline");

                const res = await fetch(`/api/data/patterns/${id}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (res.ok) {
                    alert("Pattern Deleted.");
                    if (window.Logger) window.Logger.log('DELETE_PATTERN', `Deleted pattern ID: ${id}`);
                    loadFromCloud();
                } else {
                    const err = await res.text();
                    alert(`Failed to delete (Server ${res.status}): ${err}`);
                }
            } catch (e) {
                console.error(e);
                alert("Delete Failed: " + e.message);
            }
        }

        // --- EXPORT LOGIC ---

        let currentExportPatternId = null;

        async function openExportForPattern(id) {
            currentExportPatternId = id;
            const p = patterns.find(x => x.id === id);

            document.getElementById('metaPattern').value = p.name || "";
            document.getElementById('metaSchool').value = sessionStorage.getItem('schoolName') || ""; // Try to prefill if available
            document.getElementById('metaDesc').value = p.description || "";
            document.getElementById('metaConsumption').value = p.consumption || "";
            document.getElementById('metaClothDetails').value = p.cloth_details || "";
            document.getElementById('metaSpecialReq').value = p.notes || "";

            document.getElementById('exportFilters').textContent = p.name; // Simplified filter text

            // Must Ensure Data is Correct (Reload Filters quietly)
            // This ensures we calculate totals based on CURRENT data matching filters
            loadPattern(id);

            // Calculate Item Totals based on filtered data
            const filteredData = getFilteredData();
            const itemTotals = {};
            allItems.forEach(item => {
                let sum = 0;
                filteredData.forEach(r => {
                    const val = parseFloat(r[`Qty_${item.name}`]) || 0;
                    sum += val;
                });
                if (sum > 0) itemTotals[item.name] = sum;
            });

            // Render Item Summary
            const summaryContainer = document.getElementById('exportItemSummary');
            if (summaryContainer) {
                if (Object.keys(itemTotals).length > 0) {
                    summaryContainer.innerHTML = Object.entries(itemTotals).map(([name, qty]) => `
                        <div class="flex justify-between items-center bg-gray-50 border border-gray-200 rounded px-2 py-1 text-xs">
                            <span class="font-medium text-gray-600 truncate mr-2" title="${name}">${name}</span>
                            <span class="font-bold text-gray-800">${qty}</span>
                        </div>
                    `).join('');
                } else {
                    summaryContainer.innerHTML = '<span class="text-xs text-gray-400 italic">No item quantities found.</span>';
                }
            }

            document.getElementById('exportModal').classList.remove('hidden');
            updateExportTotal();
        }

        async function savePatternMetadata() {
            if (!currentExportPatternId) return;
            const p = patterns.find(x => x.id === currentExportPatternId);
            if (!p) return;

            const newDesc = document.getElementById('metaDesc').value;
            const newCons = parseFloat(document.getElementById('metaConsumption').value) || 0;
            const newCloth = document.getElementById('metaClothDetails').value;
            const newNotes = document.getElementById('metaSpecialReq').value;
            const newName = document.getElementById('metaPattern').value;

            // Recalculate summary for saving
            const filteredData = getFilteredData();
            const itemTotals = {};
            allItems.forEach(item => {
                let sum = 0;
                filteredData.forEach(r => {
                    const val = parseFloat(r[`Qty_${item.name}`]) || 0;
                    sum += val;
                });
                if (sum > 0) itemTotals[item.name] = sum;
            });
            const itemSummaryArray = Object.entries(itemTotals).map(([name, qty]) => ({ name, qty }));


            // Construct Payload (Similar to Update Pattern but focuses on metadata)
            // We need to send everything required by the PUT endpoint
            // We reuse existing student links/quantities

            // NOTE: We rely on the fact that `p.filters` is up to date.
            // But wait, `openExportForPattern` called `loadPattern`, so global `filters` matches `p`.

            const payload = {
                school_id: sessionStorage.getItem('schoolId'),
                name: newName || p.name,
                description: newDesc,
                consumption: newCons,
                cloth_details: newCloth,
                special_req: JSON.stringify({
                    filters: p.filters,
                    notes: newNotes,
                    item_summary: itemSummaryArray
                }),
                // We must send quantities/students to avoid clearing them or erroring??
                // The PUT endpoint checks: "if student_ids ... relink". If we omit student_ids, it leaves them unchanged.
                // It also updates quantities. If we omit, it might set to null or error?
                // Looking at PUT generic: "quantities=?"
                // So we should ideally preserve existing quantities.
                // However, we don't have the raw massive quantity object here easily unless we rebuild it.
                // OR we just pass the existing `quantities` string/json from the DB?
                // But `patterns` array doesn't currently store the raw big `quantities` blob.
                // It only stores derived counts.
                // Actually, the PUT endpoint is designed for FULL updates.
                // If we want a lightweight metadata update, we might need to modify the backend or be careful.
                // Let's look at backend: `const qtyJson = ...`. It updates `quantities=?`.
                // If we send `undefined`, `qtyJson` is undefined, update sets it to NULL?
                // NO, `JSON.stringify(undefined)` is undefined.
                // `UPDATE ... quantities=?` with `undefined` -> SQL error or NULL?
                // DB driver usually expects a value.

                // Workaround: We really should have a PATCH or specific metadata update.
                // BUT, since we already implemented PUT to RE-CALCULATE quantities on update...
                // Maybe we should just re-calculate quantities here too?
                // Yes, simpler to just treat this as a full update.
            };

            // Re-calculate full payload logic
            const currentData = getFilteredData();
            let totalConsumption = 0;
            const studentIds = [];
            const studentQuantities = currentData.map(student => {
                if (student.id) studentIds.push(student.id);
                const qties = {};
                Object.keys(student).forEach(k => {
                    if (k.startsWith("Qty_")) {
                        qties[k] = parseFloat(student[k]) || 0;
                        totalConsumption += qties[k];
                    }
                });
                return {
                    admission_no: student['Admission No'],
                    name: student['Student Name'],
                    quantities: qties
                };
            });

            payload.consumption = newCons; // Use manual override if provided? Or calculated?
            // User typed consumption is usually "Cloth per student". 
            // Calculated `totalConsumption` above is sum of dress quantities. Distinct things.
            // DB `consumption` column usage: "Aggergate total" or "Per Unit"?
            // In `savePattern`: `consumption: parseFloat(totalConsumption.toFixed(2))` (Aggregate)
            // But in UI modal: "Cloth Consumption (M/Student)" -> used to calc Total Cloth.
            // This implies a conflict in definition.
            // If user types "2.5M per student", Total = 2.5 * N.
            // If `savePattern` saves Sum(Qty), that's different.
            // Let's stick to what the Export Modal DOES: It calculates Total Cloth based on Input * Count.
            // So we should save the Input (Per Student) somewhere? 
            // OR save the Result (Total)?
            // Creating Pattern -> saves Sum(Qty).
            // Exporting Pattern -> User typically enters average consumption.
            // Let's update `consumption` to be the Total Cloth (calculated or manual).
            // Actually, if we allow editing, we should save what they typed.
            // Let's assume `consumption` field = Total Cloth.
            // And we add a new field `consumption_rate`? Or just overload?
            // Let's just update `consumption` with the raw value from the input FOR NOW.
            // Wait, the input label says "M/Student".
            // So `consumption` in DB = M/Student?
            // In `savePattern`: `consumption: parseFloat(totalConsumption.toFixed(2))` -> This looks like Total.
            // Detailed Check: `totalConsumption += qties[k]`. Sum of ALL quantities.
            // So `savePattern` saves TOTAL items? No, quantities are usually integers (1 shirt).
            // So `totalConsumption` = Total Items count?
            // The Label is "Cloth Consumption".
            // Confusing usage.
            // Let's Standardize: DB `consumption` = Total Estimated Cloth.
            // In Export Modal, user types "Rate". Total = Rate * Count.
            // We should save Total to `consumption`.
            // But we also want to remember the "Rate"?
            // We can save Rate in `notes` or just back-calculate.
            // Let's save `consumption` as the TOTAL CLOTH (Rate * Count).

            const rate = newCons; // The input value
            const totalCloth = (rate * currentData.length).toFixed(2);
            payload.consumption = parseFloat(totalCloth);
            payload.quantities = studentQuantities;
            payload.student_ids = studentIds;

            try {
                const token = sessionStorage.getItem('token');
                if (!token) throw new Error("Offline");

                const res = await fetch(`/api/data/patterns/${currentExportPatternId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                    body: JSON.stringify(payload)
                });

                if (res.ok) {
                    alert("Pattern Details Saved!");
                    if (window.Logger) window.Logger.log('UPDATE_PATTERN_METADATA', `Updated metadata for pattern ID: ${currentExportPatternId}`);
                    // Update Local State
                    p.description = newDesc;
                    p.consumption = parseFloat(totalCloth);
                    p.cloth_details = newCloth;
                    p.notes = newNotes;
                    p.saved_item_summary = itemSummaryArray;

                    loadFromCloud(); // Safest
                } else {
                    const errText = await res.text();
                    console.error("Save Failed:", res.status, errText);
                    alert(`Failed to save (Server ${res.status}): ${errText}`);
                }
            } catch (e) {
                console.error(e);
                alert("Offline: Saved locally.");
                // Local update
                p.description = newDesc;
                p.consumption = parseFloat((newCons * currentData.length).toFixed(2));
                p.cloth_details = newCloth;
                p.notes = newNotes;
                p.saved_item_summary = itemSummaryArray;
                saveToLocal();
            }
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.add('hidden');
        }

        function updateExportTotal() {
            const consumption = parseFloat(document.getElementById('metaConsumption').value) || 0;
            const filtered = getFilteredData();
            // Count "Active" Students: For simplistic grouping, every row is a student.
            const total = (filtered.length * consumption).toFixed(2);
            document.getElementById('exportTotalCloth').textContent = `${total} M`;
        }

        async function confirmExportPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape' });

            // Metadata Block
            const school = document.getElementById('metaSchool').value;
            const code = document.getElementById('metaPattern').value;
            const desc = document.getElementById('metaDesc').value;
            const cloth = document.getElementById('metaClothDetails').value;
            const req = document.getElementById('metaSpecialReq').value;
            const totalCloth = document.getElementById('exportTotalCloth').textContent;

            let y = 15;
            doc.setFontSize(14); doc.text(`Pattern Group: ${code}`, 14, y); y += 8;
            doc.setFontSize(10);
            if (school) { doc.text(`School: ${school}`, 14, y); y += 6; }
            if (desc) { doc.text(`Desc: ${desc}`, 14, y); y += 6; }
            if (cloth) { doc.text(`Cloth: ${cloth}`, 14, y); y += 6; }
            if (req) { doc.text(`Special: ${req}`, 14, y); y += 6; }
            doc.text(`Total Qty: ${getFilteredData().length} Students | Total Cloth: ${totalCloth}`, 14, y); y += 10;

            // Determine Cols
            const activeItemName = filters.item;
            const itemHeaders = activeItemName ? [activeItemName, "Qty"] : [];

            const rows = getFilteredData().map(r => {
                const base = [r['Roll No'], r['Student Name'], r['Class'], r['Section'], ...measureCols.map(m => r[m])];
                if (activeItemName) {
                    const item = allItems.find(i => i.name === activeItemName);
                    if (item) {
                        base.push(calculateItemValue(r, item));
                        base.push(r[`Qty_${item.name}`] || "");
                    }
                }
                return base;
            });

            doc.autoTable({
                head: [['Roll', 'Name', 'Class', 'Sec', ...measureCols, ...itemHeaders]],
                body: rows,
                startY: y,
                styles: { fontSize: 8, cellPadding: 2 }
            });
            doc.save(`Pattern_${code}.pdf`);
            if (window.Logger) window.Logger.log('EXPORT_PATTERN_PDF', `Exported Pattern PDF: ${code}`);
            closeExportModal();
        }

        function confirmExport() {
            const wb = XLSX.utils.book_new();
            const filtered = getFilteredData();

            const school = document.getElementById('metaSchool').value;
            const code = document.getElementById('metaPattern').value;
            const desc = document.getElementById('metaDesc').value;
            const cloth = document.getElementById('metaClothDetails').value;
            const req = document.getElementById('metaSpecialReq').value;
            const totalCloth = document.getElementById('exportTotalCloth').textContent;



            const activeItemName = filters.item;
            const itemHeaders = activeItemName ? [activeItemName, "Quantity"] : [];

            const wsData = [
                ["PATTERN GROUP EXPORT"],
                ["Pattern Code", code],
                ["School Name", school],
                ["Description", desc],
                ["Cloth Details", cloth],
                ["Special Requirements", req],
                ["Total Cloth Needed", totalCloth],
                ["Total Students", filtered.length],
                [],
                ["Roll No", "Student Name", "Class", "Section", "Gender", ...measureCols, ...itemHeaders]
            ];

            filtered.forEach(r => {
                const rowArr = [
                    r['Roll No'], r['Student Name'], r['Class'], r['Section'], r['Gender'],
                    ...measureCols.map(m => r[m])
                ];
                if (activeItemName) {
                    const item = allItems.find(i => i.name === activeItemName);
                    if (item) {
                        rowArr.push(calculateItemValue(r, item));
                        rowArr.push(r[`Qty_${item.name}`] || "");
                    }
                }
                wsData.push(rowArr);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, "Pattern");
            XLSX.writeFile(wb, `Pattern_${code}.xlsx`);
            if (window.Logger) window.Logger.log('EXPORT_PATTERN_EXCEL', `Exported Pattern Excel: ${code}`);
            closeExportModal();
        }

    </script>

    <!-- LOGS MODAL -->
    <div id="logs-modal"
        class="fixed inset-0 bg-black/50 hidden z-[70] flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl h-[80vh] flex flex-col overflow-hidden">
            <div class="p-4 bg-stone-900 text-white flex justify-between items-center">
                <h3 class="font-brand font-bold text-lg">My Activity Logs</h3>
                <button onclick="document.getElementById('logs-modal').classList.add('hidden')"
                    class="text-stone-400 hover:text-white">âœ•</button>
            </div>
            <div class="p-4 border-b flex justify-between bg-stone-50">
                <p class="text-xs text-stone-500 font-bold uppercase tracking-wider mt-2">Retention: 7 Days</p>
                <div class="flex gap-2">
                    <button onclick="fetchUserLogs()"
                        class="px-3 py-1 bg-white border rounded text-xs font-bold hover:bg-stone-50">Refresh</button>

                </div>
            </div>
            <div class="flex-1 overflow-auto p-4">
                <table class="w-full text-left border-collapse">
                    <thead>
                        <tr class="bg-stone-100 border-b border-stone-200">
                            <th class="p-3 text-xs font-bold text-stone-500 uppercase">Time</th>
                            <th class="p-3 text-xs font-bold text-stone-500 uppercase">Action</th>
                            <th class="p-3 text-xs font-bold text-stone-500 uppercase">Details</th>
                        </tr>
                    </thead>
                    <tbody id="userLogsBody" class="divide-y divide-stone-100">
                        <tr>
                            <td colspan="3" class="p-8 text-center text-stone-400">Loading...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // LOGS LOGIC
        const API_BASE = '/api'; // Ensure API_BASE is available if not already

        function openLogs() {
            document.getElementById('logs-modal').classList.remove('hidden');
            fetchUserLogs();
        }

        async function fetchUserLogs() {
            const token = sessionStorage.getItem('token');
            const tbody = document.getElementById('userLogsBody');
            tbody.innerHTML = '<tr><td colspan="3" class="p-8 text-center text-stone-400">Loading...</td></tr>';
            try {
                const res = await fetch(`${API_BASE}/data/logs?days=7`, { headers: { 'Authorization': `Bearer ${token}` } });
                const data = await res.json();
                if (res.ok && Array.isArray(data)) {
                    if (data.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="3" class="p-8 text-center text-stone-400">No logs found.</td></tr>';
                    } else {
                        tbody.innerHTML = data.map(l => `
                                <tr>
                                    <td class="p-3 text-xs font-mono text-stone-500">${new Date(l.created_at).toLocaleString()}</td>
                                    <td class="p-3 text-xs font-bold text-stone-700">${l.action}</td>
                                    <td class="p-3 text-xs text-stone-600">${l.details}</td>
                                </tr>
                            `).join('');
                    }
                    window.currentUserLogs = data;
                } else {
                    tbody.innerHTML = '<tr><td colspan="3" class="p-8 text-center text-rose-500">Error loading logs.</td></tr>';
                }
            } catch (e) { tbody.innerHTML = '<tr><td colspan="3" class="p-8 text-center text-rose-500">Connection Failed.</td></tr>'; }
        }

        function downloadUserLogs(fmt) {
            const data = window.currentUserLogs || [];
            if (data.length === 0) return alert("No data.");
            let csv = "Time,Action,Details\n";
            data.forEach(l => csv += `"${new Date(l.created_at).toLocaleString()}","${l.username}","${l.action}","${(l.details || '').replace(/"/g, '""')}"\n`);
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'My_Logs.csv'; a.click();
        }
    </script>
    <script src="js/logger.js"></script>
    <script>
        window.addEventListener('load', () => {
            const u = sessionStorage.getItem('username');
            if (u && Logger) Logger.log('PATTERN_DASHBOARD_LOAD', `Loaded by ${u}`);
        });
    </script>
</body>

</html> modal.classList.remove('hidden');
}

function closeTrashModal() {
document.getElementById('trashModal').classList.add('hidden');
}

function restorePattern(i) {
const p = trashPatterns[i];
patterns.push(p);
trashPatterns.splice(i, 1);
saveToLocal();
saveTrash();
renderModules();
openTrashModal(); // Refresh modal
}

function permanentDelete(i) {
if (!confirm("Delete forever? This logic cannot be undone.")) return;
trashPatterns.splice(i, 1);
saveTrash();
openTrashModal();
}

function emptyTrash() {
if (!confirm(`Empty Trash? All ${trashPatterns.length} patterns will be lost forever.`)) return;
trashPatterns = [];
saveTrash();
openTrashModal();
}

// --- PACKING LIST EXPORT ---

function getPackingListData() {
// Aggregate all students from all patterns
let allRows = [];
const backupFilters = filters; // Backup global state

try {
patterns.forEach(p => {
// Temporarily Apply Filters
filters = p.filters;
const pRows = getFilteredData();
const item = allItems.find(i => i.name === p.filters.item);

pRows.forEach(r => {
let qty = 1;
if (item && r[`Qty_${item.name}`]) {
const q = parseInt(r[`Qty_${item.name}`]);
if (!isNaN(q)) qty = q;
}

// Create Simplified Row
allRows.push({
"Student Name": r["Student Name"],
"School": p.metadata?.school || "",
"Class": r["Class"],
"Section": r["Section"],
"Pattern Name": p.name,
"Gender": r["Gender"],
"House": r["House"] || "",
"Description": p.metadata?.desc || "",
"Quantity": qty,
// New Fields
"Roll No": r["Roll No"] || "",
"Admission No": r["Admission No"] || r["Adm No"] || "",
// Internal sort keys
_clsRank: getClassRank(r["Class"]),
_sec: r["Section"],
_name: r["Student Name"]
});
});
});
} finally {
filters = backupFilters; // Restore
}

// Sort by Class -> Section -> Name
allRows.sort((a, b) => {
if (a._clsRank !== b._clsRank) return a._clsRank - b._clsRank;
if (a._sec !== b._sec) return a._sec.localeCompare(b._sec);
return a._name.localeCompare(b._name);
});

return allRows;
}

function exportPackingListExcel() {
if (patterns.length === 0) return alert("No patterns to export.");

const rows = getPackingListData();
const wb = XLSX.utils.book_new();
const wsData = [
["PACKING LIST REPORT"],
[`Generated: ${new Date().toLocaleDateString()}`],
[],
["Roll No", "Admission No", "Student Name", "School", "Class", "Section", "Pattern Name", "Gender", "House",
"Description", "Quantity"]
];

rows.forEach(r => {
wsData.push([
r["Roll No"],
r["Admission No"],
r["Student Name"],
r["School"],
r["Class"],
r["Section"],
r["Pattern Name"],
r["Gender"],
r["House"],
r["Description"],
r["Quantity"]
]);
});

const ws = XLSX.utils.aoa_to_sheet(wsData);
// Widths
ws['!cols'] = [{ wch: 10 }, { wch: 15 }, { wch: 25 }, { wch: 20 }, { wch: 10 }, { wch: 10 }, { wch: 25 }, { wch: 10 }, {
wch: 15 }, { wch: 20 }, { wch: 10 }];

XLSX.utils.book_append_sheet(wb, ws, "Packing List");
XLSX.writeFile(wb, "Packing_List.xlsx");
}

async function exportPackingListPDF() {
if (patterns.length === 0) return alert("No patterns to export.");

const { jsPDF } = window.jspdf;
const doc = new jsPDF({ orientation: 'landscape' });
const rows = getPackingListData();

doc.setFontSize(16);
doc.text("Packing List Report", 14, 15);
doc.setFontSize(10);
doc.text(`Generated: ${new Date().toLocaleDateString()} | Total Items: ${rows.length}`, 14, 22);

const tableRows = rows.map(r => [
r["Roll No"],
r["Admission No"],
r["Student Name"],
r["School"],
r["Class"],
r["Section"],
r["Pattern Name"],
r["Gender"],
// r["House"], // Optional: Hide House if space is tight, or keep it
// r["Description"], // Keep essential fields
r["Quantity"]
]);

doc.autoTable({
head: [["Roll", "Adm No", "Name", "School", "Class", "Sec", "Pattern", "Gen", "Qty"]],
body: tableRows,
startY: 28,
styles: { fontSize: 9 },
headStyles: { fillColor: [44, 62, 80] }
});

doc.save("Packing_List.pdf");
}

function exportAllPatternsSummary() {
if (patterns.length === 0) return alert("No patterns to export.");

const wb = XLSX.utils.book_new();
const wsData = [
["Pattern Name", "School", "Description", "Cloth Details", "Special Req", "Item Type", "M/Size of Pattern", "Cutting
Quantity", "Total Cloth (M)", "Pattern Specifications"]
];

patterns.forEach(p => {
const m = p.metadata || {};
// Calculate correct quantity on the fly
const correctQty = calculatePatternQty(p);
// Update p.count for consistency (optional)
p.count = correctQty;

const cons = parseFloat(m.consumption) || 0;
const totalCloth = (cons * correctQty).toFixed(2);

// Construct filter summary
let specifications = [];
if (p.filters.class) specifications.push(`Class: ${p.filters.class}`);
if (p.filters.section) specifications.push(`Sec: ${p.filters.section}`);
if (p.filters.house) specifications.push(`House: ${p.filters.house}`);
if (p.filters.gender) specifications.push(`Gender: ${p.filters.gender}`);
if (p.filters.item) specifications.push(`Item: ${p.filters.item}`);
// Add Measurement Filters
if (p.filters.components) {
for (const [key, val] of Object.entries(p.filters.components)) {
if (val) specifications.push(`${key}: ${val}`);
}
}

wsData.push([
p.name,
m.school || "",
m.desc || "",
m.cloth || "",
m.req || "",
p.filters.item || "Mixed",
cons,
correctQty,
totalCloth,
specifications.join(', ')
]);
});

const ws = XLSX.utils.aoa_to_sheet(wsData);
// Auto-width
const wscols = wsData[0].map(() => ({ wch: 20 }));
ws['!cols'] = wscols;

XLSX.utils.book_append_sheet(wb, ws, "All Patterns Summary");
XLSX.writeFile(wb, "All_Patterns_Summary.xlsx");
}

function exportAllPatternsSummaryPDF() {
if (patterns.length === 0) return alert("No patterns to export.");

const { jsPDF } = window.jspdf;
const doc = new jsPDF({ orientation: 'landscape' });

doc.setFontSize(16);
doc.text("All Patterns Summary", 14, 15);
doc.setFontSize(10);
doc.text(`Generated: ${new Date().toLocaleDateString()}`, 14, 22);

const headers = [["Pattern Name", "School", "Desc", "Cloth Details", "Special Req", "M/Size of Pattern", "Cutting
Quantity", "Total Cloth (M)", "Pattern Specifications"]];
const rows = patterns.map(p => {
const m = p.metadata || {};
const correctQty = calculatePatternQty(p); // Use helper

const cons = parseFloat(m.consumption) || 0;
const totalCloth = (cons * correctQty).toFixed(2);

// Construct a summary of filters for the "Pattern Specifications" column
let specifications = [];
if (p.filters.class) specifications.push(`Class: ${p.filters.class}`);
if (p.filters.section) specifications.push(`Sec: ${p.filters.section}`);
if (p.filters.house) specifications.push(`House: ${p.filters.house}`);
if (p.filters.gender) specifications.push(`Gender: ${p.filters.gender}`);
if (p.filters.item) specifications.push(`${p.filters.item}`);
// Add Measurement Filters
if (p.filters.components) {
for (const [key, val] of Object.entries(p.filters.components)) {
if (val) specifications.push(`${key}: ${val}`);
}
}

return [
p.name,
m.school || "-",
m.desc || "-",
m.cloth || "-",
m.req || "-",
cons.toFixed(2),
correctQty,
totalCloth,
specifications.join(', ')
];
});

doc.autoTable({
head: headers,
body: rows,
startY: 25,
styles: { fontSize: 9 },
headStyles: { fillColor: [44, 62, 80] }
});

doc.save("All_Patterns_Summary.pdf");
}

</script>
</body>

</html>