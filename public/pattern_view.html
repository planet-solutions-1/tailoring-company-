<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Editor - Read Only Grouping</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>window.jsPDF = window.jspdf.jsPDF;</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F9F9F7;
            color: #2C3E50;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: 'Noto Serif JP', serif;
        }

        /* Read-only cell styling */
        .cell-read {
            background-color: transparent;
            width: 100%;
            height: 100%;
            padding: 8px;
            border: none;
            cursor: default;
        }

        .sticky-col {
            position: sticky;
            left: 0;
            z-index: 10;
            background-color: #FFFFFF;
        }

        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 20;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .btn-action {
            background-color: #4A5568;
            color: white;
            transition: all 0.2s;
        }

        .btn-action:hover {
            background-color: #2D3748;
        }

        .btn-primary {
            background-color: #C0392B;
            color: white;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            background-color: #A93226;
        }

        .btn-outline {
            background-color: #FFFFFF;
            border: 1px solid #E2E8F0;
            color: #4A5568;
            transition: all 0.2s;
        }

        .btn-outline:hover {
            background-color: #F7FAFC;
            border-color: #CBD5E0;
        }

        /* Japanese Art Watermark */
        .watermark {
            position: absolute;
            bottom: -50px;
            right: -50px;
            opacity: 0.15;
            pointer-events: none;
            z-index: 0;
            width: 400px;
            height: 400px;
        }
    </style>
</head>

<body class="h-screen flex flex-col overflow-hidden relative">

    <svg class="watermark" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <filter id="ink-blur" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.5" />
            </filter>
        </defs>
        <circle cx="220" cy="60" r="35" fill="#C0392B" opacity="0.8" style="mix-blend-mode: multiply;" />
        <g stroke="#2C3E50" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round" opacity="0.9">
            <path d="M260 300 Q270 200 240 100" stroke-width="4" />
            <path d="M220 300 Q230 250 210 180" stroke-width="2.5" />
        </g>
    </svg>

    <!-- Create Pattern Modal -->
    <div id="patternModal"
        class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm p-4">
        <div
            class="bg-white rounded-lg shadow-xl w-[95%] sm:w-full max-w-md flex flex-col overflow-hidden animate-in fade-in zoom-in duration-200">
            <div class="px-6 py-4 border-b border-[#E2E8F0] bg-[#F9F9F7]">
                <h3 class="font-bold text-[#2C3E50] text-lg">Create Pattern Group</h3>
            </div>
            <div class="p-6 space-y-4">
                <div>
                    <label class="block text-xs font-semibold text-[#7F8C8D] uppercase mb-1">Pattern Name</label>
                    <input type="text" id="newPatternName"
                        class="w-full border border-gray-300 rounded p-2 text-sm focus:border-blue-500 outline-none"
                        placeholder="e.g. Class 10 Boys Bundle">
                </div>
                <div
                    class="bg-blue-50 p-3 rounded text-xs text-blue-800 border border-blue-100 flex justify-between items-center">
                    <div>
                        <p>Items in Pattern: <span id="patternCountDisplay" class="font-bold">0</span> Students</p>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="block text-xs font-semibold text-[#7F8C8D] uppercase mb-1">School Name</label>
                        <select id="newPatternSchool"
                            class="w-full border border-gray-300 rounded p-2 text-sm focus:border-blue-500 outline-none bg-white">
                            <option value="">Loading Schools...</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs font-semibold text-[#7F8C8D] uppercase mb-1">Consumption (M)</label>
                        <input type="number" step="0.01" id="newPatternCons"
                            class="w-full border border-gray-300 rounded p-2 text-sm focus:border-blue-500 outline-none"
                            placeholder="0.00">
                    </div>
                </div>

                <div>
                    <label class="block text-xs font-semibold text-[#7F8C8D] uppercase mb-1">Description</label>
                    <textarea id="newPatternDesc" rows="2"
                        class="w-full border border-gray-300 rounded p-2 text-sm focus:border-blue-500 outline-none"
                        placeholder="Brief description..."></textarea>
                </div>

                <div>
                    <label class="block text-xs font-semibold text-[#7F8C8D] uppercase mb-1">Cloth Details</label>
                    <input type="text" id="newPatternCloth"
                        class="w-full border border-gray-300 rounded p-2 text-sm focus:border-blue-500 outline-none"
                        placeholder="e.g. Cotton Mix">
                </div>

                <div>
                    <label class="block text-xs font-semibold text-[#7F8C8D] uppercase mb-1">Special
                        Requirements</label>
                    <input type="text" id="newPatternReq"
                        class="w-full border border-gray-300 rounded p-2 text-sm focus:border-blue-500 outline-none"
                        placeholder="Optional...">
                </div>
            </div>
            <div class="px-6 py-4 border-t border-[#E2E8F0] bg-[#F9F9F7] flex justify-end gap-3">
                <button onclick="document.getElementById('patternModal').classList.add('hidden')"
                    class="btn-outline px-4 py-2 rounded text-sm">Cancel</button>
                <button onclick="savePattern()" class="btn-primary px-6 py-2 rounded text-sm shadow-md">Create
                    Pattern</button>
            </div>
        </div>
    </div>


    <!-- Export Modal (Reused Logic) -->
    <div id="exportModal"
        class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm p-4">
        <div
            class="bg-white rounded-lg shadow-xl w-[95%] sm:w-full max-w-2xl max-h-[90vh] flex flex-col overflow-hidden animate-in fade-in zoom-in duration-200">
            <div class="px-6 py-4 border-b border-[#E2E8F0] bg-[#F9F9F7] flex justify-between items-center">
                <h3 class="font-bold text-[#2C3E50] text-lg">Export Pattern</h3>
                <button onclick="closeExportModal()" class="text-gray-400 hover:text-gray-600">×</button>
            </div>
            <div class="p-6 space-y-4 overflow-y-auto">
                <div class="grid grid-cols-2 gap-4">
                    <div><label class="block text-xs uppercase text-gray-500">School Name</label><input type="text"
                            id="metaSchool" class="w-full border p-2 rounded text-sm"></div>
                    <div><label class="block text-xs uppercase text-gray-500">Pattern Code</label><input type="text"
                            id="metaPattern" class="w-full border p-2 rounded text-sm"></div>
                </div>
                <div><label class="block text-xs uppercase text-gray-500">Description</label><textarea id="metaDesc"
                        rows="2" class="w-full border p-2 rounded text-sm"></textarea></div>

                <div class="bg-[#F0F4F8] p-4 rounded-md border border-[#CBD5E0]">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-xs font-bold uppercase">Cloth Consumption (M/Student)</label>
                        <input type="number" id="metaConsumption" step="0.01" class="w-32 border p-1 rounded text-right"
                            placeholder="0.00" oninput="updateExportTotal()">
                    </div>
                    <div class="flex justify-between text-xs text-gray-500 pt-2 border-t border-gray-300">
                        <span>Total Cloth Needed:</span>
                        <span id="exportTotalCloth" class="font-bold text-lg text-gray-800">0.00 M</span>
                    </div>
                </div>

                <!-- Additional Metadata Fields -->
                <div>
                    <label class="block text-xs uppercase text-gray-500">Cloth Details</label>
                    <textarea id="metaClothDetails" rows="2" class="w-full border p-2 rounded text-sm"
                        placeholder="e.g. Cotton 100%"></textarea>
                </div>
                <div>
                    <label class="block text-xs uppercase text-gray-500">Special Requirements</label>
                    <textarea id="metaSpecialReq" rows="2" class="w-full border p-2 rounded text-sm"
                        placeholder="Any special instructions..."></textarea>
                </div>

                <div class="text-xs text-gray-500 bg-gray-50 p-2 rounded border border-gray-200">
                    <strong>Filters in this Pattern:</strong> <span id="exportFilters" class="italic"></span>
                </div>
            </div>
            <div class="px-6 py-4 border-t bg-[#F9F9F7] flex justify-end gap-3">
                <button onclick="confirmExportPDF()"
                    class="btn-outline px-4 py-2 rounded text-sm text-red-600 border-red-200 hover:bg-red-50">Export
                    PDF</button>
                <button onclick="confirmExport()" class="btn-action px-6 py-2 rounded text-sm">Export Excel</button>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header
        class="bg-white border-b border-[#E2E8F0] px-4 sm:px-6 py-4 flex flex-col lg:flex-row justify-between items-center shadow-sm z-30 relative gap-4">
        <div class="flex items-center gap-4 w-full lg:w-auto justify-center lg:justify-start">
            <div class="bg-gradient-to-br from-[#C0392B] to-[#922B21] text-white p-2 rounded-md shadow-sm shrink-0">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <path d="M14 2v6h6"></path>
                    <path d="M16 13H8"></path>
                    <path d="M16 17H8"></path>
                    <path d="M10 9H8"></path>
                </svg>
            </div>
            <div>
                <h1 class="text-2xl font-serif text-[#2D3748] tracking-tight">Pattern Dashboard</h1>
                <p class="text-xs text-[#7F8C8D] tracking-wide">READ-ONLY GROUPING SYSTEM</p>
                <div id="userWelcome" class="text-xs font-semibold text-blue-600 mt-1 hidden">
                    Welcome, <span id="displayUser">User</span> <span id="displaySchool" class="text-gray-500"></span>
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row items-center gap-3 w-full lg:w-auto justify-center lg:justify-end">
            <a href="index.html"
                class="text-xs font-bold text-gray-500 hover:text-gray-800 uppercase tracking-wide mr-0 sm:mr-4 order-2 sm:order-1">
                &larr; Go to Cutting Dashboard
            </a>
            <input type="file" id="fileInput" accept=".xlsx, .xls" class="hidden" onchange="handleFileUpload(event)" />

            <div class="flex gap-2 order-1 sm:order-2 w-full sm:w-auto justify-center">
                <button onclick="clearData()"
                    class="btn-outline px-4 py-2 rounded-md text-sm font-medium text-red-600 border-red-200 hover:bg-red-50 flex items-center gap-2"
                    title="Clear saved data">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6" />
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                    </svg>
                    Clear Data
                </button>
                <button id="btn-save-cloud" onclick="syncPatternsToCloud()"
                    class="btn-outline px-4 py-2 rounded-md text-sm font-medium text-blue-600 border-blue-200 hover:bg-blue-50 flex items-center gap-2"
                    title="Save current patterns to Cloud Database">
                    <svg class="icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                        </path>
                    </svg>
                    <span>Save to Cloud</span>
                </button>
                <button id="btn-load-cloud" onclick="fetchPatternsFromBackend()"
                    class="btn-outline px-4 py-2 rounded-md text-sm font-medium text-purple-600 border-purple-200 hover:bg-purple-50 flex items-center gap-2"
                    title="Load saved patterns from Cloud Database">
                    <svg class="icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3 3m0 0l-3-3m3 3v12"
                            transform="rotate(180 12 12)"></path>
                    </svg>
                    <span>Load from Cloud</span>
                </button>
            </div>
    </header>

    <!-- Pattern List & Toolbar -->
    <div
        class="bg-[#F8F9FA] border-b border-[#E2E8F0] px-6 py-2 flex items-center gap-4 overflow-x-auto whitespace-nowrap">
        <span class="text-xs font-bold text-gray-400 uppercase tracking-wider">Saved Patterns:</span>
        <button onclick="openTrashModal()" title="Recycle Bin"
            class="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded border border-gray-200 hover:bg-gray-200 flex items-center gap-1">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            Trash (<span id="trashCount">0</span>)
        </button>
        <button onclick="exportAllPatternsSummary()"
            class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded border border-green-200 hover:bg-green-200 flex items-center gap-1">
            <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="7 10 12 15 17 10" />
                <line x1="12" y1="15" x2="12" y2="3" />
            </svg>
            Export Summary (XLSX)
        </button>
        <button onclick="exportAllPatternsSummaryPDF()"
            class="text-xs bg-red-100 text-red-700 px-2 py-1 rounded border border-red-200 hover:bg-red-200 flex items-center gap-1">
            <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
            Summary (PDF)
        </button>
        <div class="h-6 w-px bg-gray-300 mx-1"></div>
        <button onclick="exportPackingListExcel()" title="Export Packing List (All Patterns)"
            class="text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded border border-purple-200 hover:bg-purple-200 flex items-center gap-1">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="7 10 12 15 17 10" />
                <line x1="12" y1="15" x2="12" y2="3" />
            </svg>
            Packing (XLS)
        </button>
        <button onclick="exportPackingListPDF()" title="Export Packing List (All Patterns)"
            class="text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded border border-purple-200 hover:bg-purple-200 flex items-center gap-1">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                <polyline points="14 2 14 8 20 8" />
                <line x1="16" y1="13" x2="8" y2="13" />
                <line x1="16" y1="17" x2="8" y2="17" />
                <polyline points="10 9 9 9 8 9" />
            </svg>
            Packing (PDF)
        </button>

        <div id="patternList" class="flex gap-2">
            <!-- Patterns inserted here -->
            <span class="text-xs text-gray-400 italic py-1">No patterns created yet.</span>
        </div>
    </div>

    <!-- Trash Modal -->
    <div id="trashModal"
        class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm p-4">
        <div
            class="bg-white rounded-lg shadow-xl w-[95%] sm:w-full max-w-lg flex flex-col max-h-[80vh] animate-in fade-in zoom-in duration-200">
            <div class="px-6 py-4 border-b border-[#E2E8F0] bg-[#F9F9F7] flex justify-between items-center">
                <h3 class="font-bold text-[#2C3E50] text-lg flex items-center gap-2">
                    <svg width="20" height="20" class="text-red-500" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Trash Bin
                </h3>
                <button onclick="closeTrashModal()" class="text-gray-400 hover:text-gray-600">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="p-0 overflow-y-auto flex-1 bg-gray-50/50">
                <div id="trashList" class="divide-y divide-gray-100">
                    <!-- Trash Items -->
                </div>
                <div id="emptyTrashMsg" class="hidden p-8 text-center text-gray-400">
                    <p>Trash is empty.</p>
                </div>
            </div>
            <div class="px-6 py-4 border-t border-[#E2E8F0] bg-gray-50 flex justify-between">
                <button onclick="emptyTrash()"
                    class="text-red-600 hover:text-red-800 text-sm font-bold flex items-center gap-1">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path
                            d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M10 11v6M14 11v6" />
                    </svg>
                    Empty Trash
                </button>
                <button onclick="closeTrashModal()"
                    class="px-4 py-2 bg-white border border-gray-300 rounded text-sm font-medium text-gray-700 hover:bg-gray-50">Close</button>
            </div>
        </div>
    </div>

    <!-- Filters Toolbar -->
    <div
        class="bg-white border-b border-[#E2E8F0] px-4 sm:px-6 py-3 flex flex-col xl:flex-row items-center gap-4 overflow-x-auto z-20">
        <div
            class="flex flex-col sm:flex-row flex-wrap items-center gap-3 w-full xl:w-auto justify-center sm:justify-start">
            <div class="relative w-full sm:w-auto">
                <svg class="absolute left-3 top-2 text-[#A0AEC0]" width="16" height="16" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                <input type="text" id="searchInput" oninput="handleSearch()" placeholder="Search..."
                    class="pl-9 pr-3 py-1.5 text-sm border border-[#E2E8F0] rounded-md focus:border-[#4A5568] w-full sm:w-32 bg-[#F9F9F7]">
            </div>

            <div class="flex flex-wrap gap-2 w-full sm:w-auto justify-center sm:justify-start">
                <div class="relative group">
                    <input list="listClass" id="filterClass" onchange="handleFilter()" placeholder="Class (e.g. 1-3)"
                        class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 w-full sm:w-32 outline-none focus:border-[#4A5568]">
                    <datalist id="listClass"></datalist>
                </div>
                <div class="relative group">
                    <input list="listSection" id="filterSection" onchange="handleFilter()" placeholder="Sec (e.g. A,B)"
                        class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 w-full sm:w-32 outline-none focus:border-[#4A5568]">
                    <datalist id="listSection"></datalist>
                </div>
                <select id="filterHouse" onchange="handleFilter()"
                    class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 flex-1 sm:flex-none">
                    <option value="">All Houses</option>
                </select>
                <select id="filterGender" onchange="handleFilter()"
                    class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 flex-1 sm:flex-none">
                    <option value="">All Genders</option>
                </select>
            </div>

            <div class="h-px w-full sm:h-6 sm:w-px bg-gray-300 mx-2 hidden sm:block"></div>

            <select id="filterItem" onchange="handleItemFilter()"
                class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 outline-none focus:border-[#4A5568] w-full sm:w-auto max-w-none sm:max-w-[150px]">
                <option value="">Filter by Item</option>
            </select>

            <!-- Dynamic Range Filters -->
            <div id="dynamicFilters"
                class="flex flex-wrap items-center gap-2 justify-center sm:justify-start w-full sm:w-auto"></div>

            <div class="h-px w-full sm:h-6 sm:w-px bg-gray-300 mx-2 hidden sm:block"></div>

            <!-- Filter Presets Group -->
            <div class="flex items-center gap-2">
                <select id="presetSelect" onchange="//applyPreset(this.value)"
                    class="text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 w-32 outline-none focus:border-[#4A5568]">
                    <option value="">Select Preset...</option>
                </select>
                <button onclick="saveCurrentAsPreset()" title="Save current filters as preset"
                    class="p-1.5 text-blue-600 hover:bg-blue-50 rounded">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                </button>
                <button onclick="managePresets()" title="Manage Saved Presets"
                    class="p-1.5 text-gray-500 hover:bg-gray-100 rounded">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                </button>
            </div>

            <div class="h-px w-full sm:h-6 sm:w-px bg-gray-300 mx-2 hidden sm:block"></div>

            <div class="flex gap-2 w-full sm:w-auto justify-center sm:justify-start">
                <button onclick="resetView()"
                    class="text-gray-500 hover:text-gray-800 text-xs font-bold uppercase mx-2 whitespace-nowrap"
                    title="Clear all filters to create new pattern">
                    Reset / New
                </button>

                <button id="btnCreatePattern" onclick="openPatternModal()"
                    class="bg-[#2D3748] text-white px-4 py-1.5 rounded-md text-sm font-bold shadow hover:bg-[#1A202C] flex items-center gap-2 whitespace-nowrap">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 5v14"></path>
                        <path d="M5 12h14"></path>
                    </svg>
                    Create Pattern
                </button>

                <button id="btnUpdatePattern" onclick="updatePattern()"
                    class="bg-blue-600 text-white px-4 py-1.5 rounded-md text-sm font-bold shadow hover:bg-blue-700 flex items-center gap-2 hidden whitespace-nowrap">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                        <polyline points="17 21 17 13 7 13 7 21" />
                        <polyline points="7 3 7 8 15 8" />
                    </svg>
                    Update Pattern
                </button>
            </div>
        </div>

        <div class="text-xs text-gray-500 ml-auto w-full xl:w-auto text-center xl:text-right mt-2 xl:mt-0">
            Showing <span id="rowCount" class="font-bold text-gray-800">0</span> Records
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex-1 overflow-auto relative bg-[#F9F9F7]/90 z-10 flex flex-col">
        <div id="tableView" class="flex-1 overflow-auto">
            <table class="w-full border-collapse text-sm">
                <thead id="tableHead"
                    class="bg-white text-gray-500 font-medium text-xs uppercase sticky-header shadow-sm"></thead>
                <tbody id="tableBody" class="bg-white/80 backdrop-blur-sm"></tbody>
            </table>
        </div>
    </main>

    <script>
        // --- AUTHENTICATION CHECK ---
        const token = sessionStorage.getItem('token');
        const userRole = sessionStorage.getItem('role');
        const userSchoolId = sessionStorage.getItem('schoolId');

        if (!token) {
            window.location.href = 'login.html';
        }

        let data = [];
        let patterns = [];
        let currentWorkbook = null;
        let loadedPatternId = null;

        let filters = { search: '', class: '', section: '', house: '', gender: '', item: '', components: {} };

        // Persistence Keys
        const STORAGE_KEY_DATA = 'pattern_dashboard_data';
        const STORAGE_KEY_PATTERNS = 'pattern_dashboard_patterns';

        // --- PERSISTENCE ---
        function saveToLocal() {
            try {
                localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(data));
                localStorage.setItem(STORAGE_KEY_PATTERNS, JSON.stringify(patterns));
            } catch (e) {
                console.warn("Storage full or disabled", e);
            }
        }

        function loadFromLocal() {
            try {
                const sData = localStorage.getItem(STORAGE_KEY_DATA);
                const sPatterns = localStorage.getItem(STORAGE_KEY_PATTERNS);
                if (sData) {
                    data = JSON.parse(sData);
                    populateFilters();
                    renderTable();
                    updateCount();
                }
                if (sPatterns) {
                    // Merge or Override? Let's treat Server as source of truth if we are fetching.
                    // But init load is local.
                    patterns = JSON.parse(sPatterns);
                    renderModules();
                }
            } catch (e) { console.error(e); }
        }

        async function fetchPatternsFromBackend() {
            try {
                const res = await fetch('/api/data/patterns', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (res.ok) {
                    const dbPatterns = await res.json();

                    // Transform DB patterns to UI format
                    const mappedPatterns = dbPatterns.map(p => ({
                        id: p.id,
                        name: p.name,
                        filters: p.filters ? JSON.parse(p.filters) : {}, // Restore Filters
                        // count: p.student_count || 0, // Server doesn't send count yet, maybe calculate?
                        // For now, if we don't have local data matching school, count is 0.
                        // We rely on "Load Pattern" to re-calculate count against CURRENT loaded data.
                        count: "?", // Visual indicator until loaded
                        metadata: {
                            school: "Server Linked", // We could fetch name but logic is tricky
                            // We can use the 'users' school name or fetch from /schools lookup
                            desc: "",
                            consumption: p.consumption,
                            cloth: p.cloth_details,
                            req: p.special_req
                        },
                        schoolId: p.school_id
                    }));

                    // Logic: Append to patterns? 
                    // Or Replace? 
                    // If we want "Global Access", we should probably PRIORITIZE Server patterns.
                    // But we might have unsaved local ones.
                    // Let's MERGE by ID, preferring Server.

                    const localIds = new Set(patterns.map(p => p.id));
                    mappedPatterns.forEach(mp => {
                        // Check if exists locally (by loose matching name? or just append?)
                        // Since DB IDs are integers (1, 2) and Local are Dates (163...), they won't collide.
                        patterns.push(mp);
                    });

                    renderModules();
                }
            } catch (e) { console.error("Pattern Sync Error", e); }
        }

        function clearData() {
            if (confirm("Are you sure you want to clear all data and patterns? This cannot be undone.")) {
                localStorage.removeItem(STORAGE_KEY_DATA);
                localStorage.removeItem(STORAGE_KEY_PATTERNS);
                location.reload();
            }
        }

        // Load on Init
        window.addEventListener('DOMContentLoaded', () => {
            loadFromLocal();
            fetchSchools();
            fetchPatternsFromBackend();

            // Show User Info
            const uName = sessionStorage.getItem('username');
            const sName = sessionStorage.getItem('schoolName');
            if (uName) {
                document.getElementById('userWelcome').classList.remove('hidden');
                document.getElementById('displayUser').textContent = uName;
                if (sName) document.getElementById('displaySchool').textContent = `— ${sName}`;
            }
        });

        // --- BACKEND INTEGRATION ---
        async function fetchSchools() {
            try {
                const res = await fetch('/api/schools', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!res.ok) throw new Error("Failed to load schools");
                const schools = await res.json();

                const sel = document.getElementById('newPatternSchool');
                sel.innerHTML = '<option value="">Select School</option>';

                schools.forEach(s => {
                    const opt = document.createElement('option');
                    opt.value = s.id;
                    opt.textContent = s.name;
                    sel.appendChild(opt);
                });

                // Auto-Select if only one (RBAC)
                if (schools.length === 1) {
                    sel.value = schools[0].id;
                    sel.disabled = true; // Lock it
                }
            } catch (e) {
                console.error("School Fetch Error", e);
                // Fallback to text input if API fails? No, critical dependency now.
                document.getElementById('newPatternSchool').innerHTML = '<option value="">Error loading schools</option>';
            }
        }

        async function syncPatternsToCloud() {
            if (patterns.length === 0) return alert("No patterns to sync.");
            if (!confirm(`Sync ${patterns.length} patterns to Cloud?`)) return;

            const btn = document.getElementById('btn-save-cloud');
            const originalHTML = btn.innerHTML;
            const setBtnLoading = (text) => {
                btn.innerHTML = `<svg class="animate-spin h-4 w-4 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>${text}`;
            };

            setBtnLoading("Starting...");
            btn.disabled = true;

            try {
                let successCount = 0;
                let total = patterns.length;

                for (let i = 0; i < total; i++) {
                    const p = patterns[i];
                    setBtnLoading(`Saving ${i + 1}/${total}...`);

                    // Determine School ID (Fallback to dropdown or user's school)
                    let targetSchoolId = p.schoolId;
                    if (!targetSchoolId) {
                        const sel = document.getElementById('newPatternSchool');
                        if (sel && sel.value) targetSchoolId = sel.value;
                    }

                    // Prepare Payload
                    const payload = {
                        name: p.name,
                        consumption: (p.metadata && p.metadata.consumption) || 0,
                        cloth_details: (p.metadata && p.metadata.cloth) || "",
                        special_req: (p.metadata && p.metadata.req) || "",
                        school_id: targetSchoolId,
                        filters: JSON.stringify(p.filters || {}),
                        student_admission_nos: p.student_admission_nos
                    };

                    const res = await fetch('/api/data/patterns', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                        body: JSON.stringify(payload)
                    });

                    if (res.ok) successCount++;
                }

                // Success Feedback
                btn.innerHTML = `<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>Saved ${successCount}!`;
                setTimeout(() => fetchPatternsFromBackend(), 1000); // Reload to get IDs
                setTimeout(() => { btn.innerHTML = originalHTML; btn.disabled = false; }, 2000);

            } catch (e) {
                console.error(e);
                btn.innerHTML = "Error!";
                setTimeout(() => { btn.innerHTML = originalHTML; btn.disabled = false; }, 2000);
            }
        }

        async function fetchPatternsFromBackend() {
            const btn = document.getElementById('btn-load-cloud');
            const originalHTML = btn ? btn.innerHTML : '';
            if (btn) {
                btn.innerHTML = `<svg class="animate-spin h-4 w-4 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Loading...`;
                btn.disabled = true;
            }



            try {
                const res = await fetch('/api/data/patterns', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (res.ok) {
                    const dbPatterns = await res.json();

                    // --- OPTIMIZED DEDUPLICATION (O(N)) ---
                    // 1. Index local patterns by ID and Name
                    const idMap = new Map();
                    const nameMap = new Map();

                    patterns.forEach(p => {
                        if (p.id) idMap.set(p.id, p);
                        if (p.name) nameMap.set(p.name, p);
                    });

                    let newCount = 0;
                    let updateCount = 0;

                    dbPatterns.forEach(p => {
                        let filters = {};
                        try { filters = JSON.parse(p.filters); } catch (e) { }

                        const mapped = {
                            id: p.id,
                            name: p.name,
                            filters: filters,
                            count: p.student_admission_nos ? JSON.parse(p.student_admission_nos).length : 0,
                            metadata: {
                                school: p.school_name,
                                desc: p.special_req,
                                consumption: p.consumption,
                                cloth: p.cloth_details,
                                req: p.special_req,
                                student_admission_nos: p.student_admission_nos ? JSON.parse(p.student_admission_nos) : []
                            },
                            student_admission_nos: p.student_admission_nos ? JSON.parse(p.student_admission_nos) : [],
                            schoolId: p.school_id
                        };

                        // Merge Logic
                        if (idMap.has(p.id)) {
                            // Update existing by ID (Server Authority)
                            // We replace the object in the map, which we will reconstruct array from later?
                            // No, simpler to just modify the object in patterns array? 
                            // Actually, let's rebuild the patterns array from scratch using the Map to ensure uniqueness.
                            idMap.set(p.id, mapped);
                            updateCount++;
                        } else if (nameMap.has(p.name) && !nameMap.get(p.name).id) {
                            // Link local unsaved pattern to server pattern
                            // Remove from nameMap (old local) and add to idMap (new server)?
                            // Better: Update nameMap entry to have ID, then put in idMap.
                            const existingLocal = nameMap.get(p.name);
                            // Merge local filters if server filters are empty? No, respect server.
                            idMap.set(p.id, mapped);
                            // IMPORTANT: We must ensure this 'name' doesn't produce a duplicate unsaved entry.
                            // We will process all dbPatterns first, putting them in idMap.
                            // Then we process local 'unsaved' patterns, adding them only if name not in idMap.
                            updateCount++;
                        } else {
                            // New from Server
                            idMap.set(p.id, mapped);
                            newCount++;
                        }
                    });

                    // Reconstruct patterns array
                    // 1. All Server Patterns (from idMap)
                    const newPatternList = Array.from(idMap.values());

                    // 2. Unsaved Local Patterns (that didn't get linked)
                    // We iterate original patterns, if !id AND name is not covered by newPatternList
                    const serverNames = new Set(newPatternList.map(p => p.name));
                    patterns.forEach(p => {
                        if (!p.id && !serverNames.has(p.name)) {
                            newPatternList.push(p);
                        }
                    });

                    patterns = newPatternList;

                    saveToLocal();
                    renderModules();
                    if (btn) {
                        btn.innerHTML = `<svg class="w-4 h-4 mr-2 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>Loaded ${dbPatterns.length}`;
                        setTimeout(() => { btn.innerHTML = originalHTML; btn.disabled = false; }, 2000);
                    }
                }
            } catch (e) {
                console.error("Fetch Patterns Error", e);
                if (btn) {
                    btn.innerText = "Error!";
                    setTimeout(() => { btn.innerHTML = originalHTML; btn.disabled = false; }, 2000);
                }
            }
        }

        // Constants
        const infoCols = ["S.No", "Roll No", "Admission No", "Student Name", "Class", "Section", "House", "Gender", "Absent/Present"];
        const measureCols = ["U1", "U2", "U3", "U4", "U5", "U6", "U7", "U8", "L1", "L2", "L3", "L4", "L5", "L6", "L7", "L8"];

        // Item Definitions
        const boysItems = [
            { name: "BOYS - FORMAL SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Male" },
            { name: "BOYS - TRACK T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Male" },
            { name: "BOYS - UNIFORM T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Male" },
            { name: "BOYS - JERKIN", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Male" },
            { name: "BOYS - PULLOVER", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Male" },
            { name: "BOYS - FORMAL PANT", cols: ["L1", "L2"], type: "Male" },
            { name: "BOYS - TRACK PANT", cols: ["L1", "L2"], type: "Male" },
            { name: "BOYS - FORMAL SHORTS", cols: ["L3", "L2"], type: "Male" },
            { name: "BOYS - TRACK SHORTS", cols: ["L3", "L2"], type: "Male" },
            { name: "BOYS - PANT SPECIAL CASE", cols: ["L1", "L2", "L6", "L7"], type: "Male" },
        ];
        const girlsItems = [
            { name: "GIRLS - FORMAL SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - TRACK T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - UNIFORM T-SHIRT", cols: ["U1", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - JERKIN", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Female" },
            { name: "GIRLS - FULL SLEEVE SHIRT", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Female" },
            { name: "GIRLS - PULLOVER", cols: ["U1", "U2", "U3", "U4", "U5"], type: "Female" },
            { name: "GIRLS - KURTHA SHIRT", cols: ["U7", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - SPECIAL FROCKS", cols: ["U7", "U2", "U3", "U4", "U6"], type: "Female" },
            { name: "GIRLS - FORMAL PANT", cols: ["L1", "L2"], type: "Female" },
            { name: "GIRLS - TRACK PANT", cols: ["L1", "L2"], type: "Female" },
            { name: "GIRLS - TRACK SHORTS", cols: ["L3", "L2"], type: "Female" },
            { name: "GIRLS - PINOFORE", cols: ["L4", "L2"], type: "Female" },
            { name: "GIRLS - SKIRT", cols: ["L5", "L2"], type: "Female" },
            { name: "GIRLS - PANT SPECIAL CASE", cols: ["L1", "L2", "L6", "L7"], type: "Female" },
        ];
        const allItems = [...boysItems, ...girlsItems];

        // Column Aliases for Robust Parsing
        const colAliases = {
            "S.No": ["s.no", "no", "sno", "sl.no", "sl no", "#", "ser.no", "serial no", "serial number"],
            "Section": ["section", "sec", "sec.", "class section", "class & sec", "class/sec", "grade section", "div", "division", "class-sec"],
            "Roll No": ["roll no", "rollno", "roll_no", "roll.no", "roll #"],
            "Admission No": ["admission no", "adm no", "admin no", "adm.no", "admission_no", "reg no", "register no", "admn no"],
            "Class": ["class", "grade", "standard", "std", "c", "class/grade"],
            "Gender": ["gender", "sex", "m/f"]
        };

        // --- CORE FUNCTIONS ---

        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const ab = await file.arrayBuffer();
            currentWorkbook = XLSX.read(ab);
            const ws = currentWorkbook.Sheets[currentWorkbook.SheetNames[0]];

            let headerRowIndex = 0;
            const rawRows = XLSX.utils.sheet_to_json(ws, { header: 1 });
            for (let i = 0; i < Math.min(rawRows.length, 20); i++) {
                const rowStr = JSON.stringify(rawRows[i] || []).toLowerCase();
                if (rowStr.includes("student") && rowStr.includes("name")) { headerRowIndex = i; break; }
            }

            const jsonData = XLSX.utils.sheet_to_json(ws, { range: headerRowIndex, defval: "" });

            // RELIABLE IMPORT (Array Mode) to fix Quantity Mapping
            const headerRow = rawRows[headerRowIndex];
            const dataRows = rawRows.slice(headerRowIndex + 1);

            console.log("DEBUG: Detected Header Row:", headerRow);
            console.log("DEBUG: Column Aliases:", colAliases);

            data = dataRows.map((rArr, i) => {
                const newRow = {};
                // fill info/measures
                // fill info/measures
                infoCols.forEach(col => {
                    // 1. Try Exact Match (Header === Column Name)
                    const normalizedCol = col.toLowerCase();
                    let idx = headerRow.findIndex(h => h && h.toString().trim().toLowerCase() === normalizedCol);

                    // 2. Try Known Aliases
                    if (idx === -1 && colAliases[col]) {
                        idx = headerRow.findIndex(h => h && colAliases[col].includes(h.toString().trim().toLowerCase()));
                    }

                    // 3. Last Resort: Fuzzy "Contains" Match (Use with caution, mainly for Section/Class)
                    if (idx === -1) {
                        // Only do this for specific columns to avoid false positives (e.g. "Class" matching "Classical Dance")
                        if (col === "Section" || col === "Class" || col === "Admission No") {
                            const possibleAliases = colAliases[col] || [col.toLowerCase()];
                            idx = headerRow.findIndex(h => {
                                if (!h) return false;
                                const val = h.toString().toLowerCase();
                                return possibleAliases.some(alias => val.includes(alias));
                            });
                        }
                    }

                    if (idx !== -1) newRow[col] = rArr[idx];
                });
                measureCols.forEach(col => {
                    const idx = headerRow.findIndex(h => h && h.toString().startsWith(col));
                    if (idx !== -1) newRow[col] = rArr[idx] || "00";
                    else newRow[col] = "00";
                });

                // Fill Quantities by Header Position - Robust Logic
                allItems.forEach(item => {
                    const itemIdx = headerRow.indexOf(item.name);
                    if (itemIdx !== -1) {
                        // Assume Qty is next
                        const nextCol = headerRow[itemIdx + 1];
                        if (nextCol && (nextCol.toString().toLowerCase().includes("qty") || nextCol.toString().toLowerCase().includes("quantity"))) {
                            newRow[`Qty_${item.name}`] = rArr[itemIdx + 1];
                        }
                    }
                });

                if (!newRow["S.No"]) newRow["S.No"] = i + 1;
                // Debug: Print keys for first row
                if (i === 0) console.log("DEBUG: First mapped row:", newRow);
                return newRow;
            });

            populateFilters();

            // Auto-Detect Item Logic
            // If the uploaded file contains a column header matching an item name, auto-select it.
            let detectedItem = null;
            if (headerRow) {
                for (const item of allItems) {
                    if (headerRow.some(h => h && h.toString().trim() === item.name)) {
                        detectedItem = item.name;
                        break; // Prioritize the first one found
                    }
                }
            }

            if (detectedItem) {
                document.getElementById('filterItem').value = detectedItem;
                handleItemFilter(); // This handles rendering
                // Also trigger basic filter update to ensure state consistency
                // handleFilter(); 
            } else {
                renderTable();
                updateCount();
            }
            saveToLocal(); // Save new data
        }


        // --- PRESET SYSTEM ---
        let presets = [];
        const PRESET_STORAGE_KEY = 'exal_filter_presets';

        function loadPresets() {
            try {
                const stored = localStorage.getItem(PRESET_STORAGE_KEY);
                if (stored) {
                    presets = JSON.parse(stored);
                }
            } catch (e) { console.error("Failed to load presets", e); }
            renderPresetDropdown();
        }

        function renderPresetDropdown() {
            const sel = document.getElementById('presetSelect');
            if (!sel) return;

            // Filter by Active Item
            const activeItem = document.getElementById('filterItem') ? document.getElementById('filterItem').value : "";

            // Show all if no item selected, OR if preset matches item
            const visiblePresets = presets.filter(p => {
                if (!activeItem) return true; // Show all if global filter is empty
                return p.filters.item === activeItem;
            });

            sel.innerHTML = '<option value="">Select Preset...</option>';
            visiblePresets.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.name;
                opt.textContent = p.name;
                sel.appendChild(opt);
            });
            sel.onchange = (e) => applyPreset(e.target.value);
        }

        function saveCurrentAsPreset() {
            // syncFiltersFromDOM(); // Ensure up to date (Assuming handleFilter updates 'filters')
            // Actually handleFilter updates 'filters'.
            const name = prompt("Enter a name for this filter preset:");
            if (!name) return;

            // Check duplicate
            const existing = presets.findIndex(p => p.name === name);
            // Deep copy filters
            const newPreset = { name: name, filters: JSON.parse(JSON.stringify(filters)) };

            if (existing !== -1) {
                if (!confirm(`Preset "${name}" already exists. Overwrite?`)) return;
                presets[existing] = newPreset;
            } else {
                presets.push(newPreset);
            }

            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
            renderPresetDropdown();
            // Select the newly created one
            setTimeout(() => { document.getElementById('presetSelect').value = name; }, 50);
            alert("Preset Saved!");
        }

        function applyPreset(name) {
            if (!name) return;
            const p = presets.find(x => x.name === name);
            if (!p) return;

            // Restore Logic
            filters = JSON.parse(JSON.stringify(p.filters));

            // Update DOM Elements
            const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val || ""; };
            setVal('searchInput', filters.search);
            setVal('filterClass', filters.class);
            setVal('filterSection', filters.section);
            setVal('filterHouse', filters.house);
            setVal('filterGender', filters.gender);
            setVal('filterItem', filters.item);

            // BACKUP COMPONENTS map to prevent handleItemFilter from wiping them
            const savedComponents = JSON.parse(JSON.stringify(filters.components || {}));

            // Re-trigger item filter rendering (clears dynamic inputs)
            handleItemFilter();

            // RESTORE COMPONENTS
            filters.components = savedComponents;
            const container = document.getElementById('dynamicFilters');
            if (filters.components && container) {
                Array.from(container.children).forEach(wrapper => {
                    const input = wrapper.querySelector('input');
                    if (input && filters.components[input.placeholder]) {
                        input.value = filters.components[input.placeholder];
                    }
                });
            }

            renderTable();
            updateCount();
        }

        function managePresets() {
            if (presets.length === 0) return alert("No saved presets to manage.");

            const names = presets.map((p, i) => `${i + 1}. ${p.name}`).join('\n');
            const choice = prompt(`Saved Presets:\n${names}\n\nEnter number to DELETE, or Cancel.`);
            if (!choice) return;

            const idx = parseInt(choice) - 1;
            if (idx >= 0 && idx < presets.length) {
                const p = presets[idx];
                if (confirm(`Delete preset "${p.name}"?`)) {
                    presets.splice(idx, 1);
                    localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
                    renderPresetDropdown();
                    alert("Deleted.");
                }
            } else {
                alert("Invalid selection.");
            }
        }

        // Init Presets on Load
        document.addEventListener('DOMContentLoaded', () => {
            loadPresets();
            loadTrash();
        });

        function populateFilters() {
            const getOpts = (key) => [...new Set(data.map(r => r[key]).filter(Boolean))].sort();
            const updateDatalist = (id, opts) => {
                const el = document.getElementById(id);
                el.innerHTML = opts.map(o => `<option value="${o}">`).join('');
            };

            const updateSelect = (id, opts, label) => {
                const el = document.getElementById(id);
                const currentVal = el.value;
                el.innerHTML = `<option value="">${label}</option>` + opts.map(o => `<option value="${o}">${o}</option>`).join('');
                if (opts.includes(currentVal)) el.value = currentVal;
            };

            updateDatalist('listClass', getOpts('Class'));
            updateDatalist('listSection', getOpts('Section'));
            updateSelect('filterHouse', getOpts('House'), 'All Houses');
            updateSelect('filterGender', getOpts('Gender'), 'All Genders');

            const itemSelect = document.getElementById('filterItem');
            // We want to keep the list of ALL items, not just present ones?
            // Actually, showing only present items might be better UX?
            // "pattern dashboard" should allow filtering by any known item type to create new patterns?
            // No, stick to allItems as defined constantly.
            itemSelect.innerHTML = '<option value="">Filter by Item</option>' + allItems.map(i => `<option value="${i.name}">${i.name}</option>`).join('');
        }

        function handleFilter() {
            filters.class = document.getElementById('filterClass').value;
            filters.section = document.getElementById('filterSection').value;
            filters.house = document.getElementById('filterHouse').value;
            filters.gender = document.getElementById('filterGender').value;
            renderTable();
            updateCount();
        }

        function handleItemFilter() {
            const itemName = document.getElementById('filterItem').value;
            filters.item = itemName;
            filters.components = {};

            // Refresh Presets Dropdown to show only relevant ones
            renderPresetDropdown();

            const container = document.getElementById('dynamicFilters');
            container.innerHTML = '';

            if (itemName) {
                const item = allItems.find(i => i.name === itemName);
                if (item) {
                    item.cols.forEach(col => {
                        const values = [...new Set(data.map(r => r[col]).filter(v => v && v !== "00"))].sort();

                        const wrapper = document.createElement('div');
                        wrapper.className = "relative inline-block";

                        const input = document.createElement('input');
                        input.setAttribute('list', `list-${col}`);
                        input.type = "text";
                        input.placeholder = col;
                        input.className = "text-sm border border-[#E2E8F0] rounded-md px-2 py-1.5 outline-none focus:border-[#4A5568] w-20 text-gray-600";

                        const dl = document.createElement('datalist');
                        dl.id = `list-${col}`;
                        dl.innerHTML = values.map(v => `<option value="${v}">`).join('');

                        input.onchange = (e) => {
                            if (e.target.value) filters.components[col] = e.target.value;
                            else delete filters.components[col];
                            renderTable();
                            updateCount();
                        };

                        wrapper.appendChild(input);
                        wrapper.appendChild(dl);
                        container.appendChild(wrapper);
                    });
                }
            }
            renderTable();
            updateCount();
        }

        function handleSearch() {
            filters.search = document.getElementById('searchInput').value.toLowerCase();
            renderTable();
            updateCount();
        }

        function syncFiltersFromDOM() {
            // 1. Sync Static Filters
            filters.class = document.getElementById('filterClass').value;
            filters.section = document.getElementById('filterSection').value;
            filters.house = document.getElementById('filterHouse').value;
            filters.gender = document.getElementById('filterGender').value;

            // 2. Sync Dynamic Component Filters
            // Don't rebuild them! Just read values from existing inputs.
            const container = document.getElementById('dynamicFilters');
            filters.components = {}; // Clear and rebuild based on DOM

            // Only if item selected
            const activeItem = document.getElementById('filterItem').value;
            if (activeItem && activeItem === filters.item) {
                const inputs = container.querySelectorAll('input');
                inputs.forEach(input => {
                    const col = input.getAttribute('placeholder');
                    const val = input.value.trim();
                    if (col && val) {
                        filters.components[col] = val;
                    }
                });
            }
        }



        // --- CLASS RANK LOGIC ---
        const CLASS_ORDER = ["PRE-KG", "PREKG", "LKG", "UKG", "KG", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];

        function getClassRank(cls) {
            if (!cls) return -1;
            const s = String(cls).toUpperCase().trim();
            const idx = CLASS_ORDER.indexOf(s);
            if (idx !== -1) return idx;
            // Fallback for purely numeric classes not in list (e.g. 13?)
            const num = parseFloat(s);
            if (!isNaN(num)) return CLASS_ORDER.length + num;
            return -1; // Unknown
        }

        // --- FILTER HELPERS ---
        function checkFilterMatch(rowValue, filterInput, isNumeric = false) {
            if (!filterInput) return true;
            const parts = filterInput.split(',').map(s => s.trim());

            // Check if rowValue matches ANY of the parts (OR logic between commas)
            return parts.some(part => {
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(s => s.trim());

                    if (typeof isNumeric === 'function') {
                        // Custom Rank Logic (for Classes)
                        const val = isNumeric(rowValue);
                        const sVal = isNumeric(start);
                        const eVal = isNumeric(end);
                        if (val === -1 || sVal === -1 || eVal === -1) return false;
                        return val >= sVal && val <= eVal;
                    } else if (isNumeric) {
                        const val = parseFloat(rowValue);
                        const sNum = parseFloat(start);
                        const eNum = parseFloat(end);
                        // Handle invalid numbers gracefully
                        if (isNaN(val) || isNaN(sNum) || isNaN(eNum)) return false;
                        return val >= sNum && val <= eNum;
                    } else {
                        // String range (lexicographical) - case insensitive
                        const rVal = String(rowValue || "").toLowerCase();
                        const sVal = start.toLowerCase();
                        const eVal = end.toLowerCase();
                        return rVal >= sVal && rVal <= eVal;
                    }
                } else {
                    // Single value match
                    if (typeof isNumeric === 'function') {
                        // For single values in Rank Mode, usually explicit match expected
                        // But "1" (Rank 5) == "1" (Rank 5) works.
                        // "LKG" (Rank 2) == "LKG" (Rank 2) works.
                        const val = isNumeric(rowValue);
                        const pVal = isNumeric(part);
                        // If both are valid ranks, compare ranks. 
                        // If part is not a valid rank (e.g. "Class A" not in list), strict inequality
                        if (val !== -1 && pVal !== -1) return val === pVal;
                        // Fallback to string match if ranks fail?
                        return String(rowValue || "").toLowerCase() === part.toLowerCase();
                    } else if (isNumeric) {
                        // Loose equality for numbers in strings (e.g. "5" == 5)
                        return String(rowValue) == part;
                    } else {
                        // Exact string match (case-insensitive)
                        return String(rowValue || "").toLowerCase() === part.toLowerCase();
                    }
                }
            });
        }

        function getFilteredData() {
            return data.filter(row => {
                // 1. Basic Filters
                const matchSearch = !filters.search || Object.values(row).some(v => String(v).toLowerCase().includes(filters.search));
                // Use Helper Helper for Range Support
                // Pass getClassRank function for custom class ordering (LKG < UKG < 1)
                const matchClass = checkFilterMatch(row.Class, filters.class, getClassRank);
                const matchSection = checkFilterMatch(row.Section, filters.section, false);
                // Keep House/Gender as exact (selects)
                const matchHouse = !filters.house || row.House == filters.house;
                const matchGender = !filters.gender || row.Gender == filters.gender;

                // 2. Item Gender Logic
                let matchItem = true;
                if (filters.item) {
                    const item = allItems.find(i => i.name === filters.item);
                    if (item) {
                        const gender = (row.Gender || "").toUpperCase();
                        if (item.type === "Male" && gender !== "MALE") matchItem = false;
                        if (item.type === "Female" && gender !== "FEMALE") matchItem = false;
                    }
                }

                // 3. Component Range Logic (The "Advanced" part)
                let matchComp = true;
                if (filters.item) {
                    Object.keys(filters.components).forEach(col => {
                        const filterVal = filters.components[col];
                        const rowVal = row[col];

                        // Use the shared helper for robust range support (Numeric for measurements)
                        // Measurements (U1-U8, L1 etc) are numeric.
                        if (!checkFilterMatch(rowVal, filterVal, true)) {
                            matchComp = false;
                        }
                    });
                }

                return matchSearch && matchClass && matchSection && matchHouse && matchGender && matchItem && matchComp;
            });
        }

        function calculateItemValue(row, item) {
            const parts = item.cols.map(col => {
                const v = row[col];
                return (v && v !== '00') ? v : "00";
            });
            return parts.join(",");
        }

        function renderTable() {
            const filtered = getFilteredData();
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');

            // Header
            let h = `<tr class="bg-[#F7FAFC]">
                <th class="p-3 border-b border-r min-w-[50px] text-center font-bold text-gray-600">#</th>
                <th class="p-3 border-b border-r min-w-[200px] text-left font-bold text-gray-600 sticky-col z-20">Student Name</th>
                <th class="p-3 border-b border-r min-w-[80px]">Class</th>
                <th class="p-3 border-b border-r min-w-[80px]">Sec</th>
                <th class="p-3 border-b border-r min-w-[80px]">Gender</th>
                <th class="p-3 border-b border-r min-w-[100px]">Adm No</th>`;

            measureCols.forEach(c => {
                const color = c.startsWith('U') ? 'text-blue-600 bg-blue-50' : 'text-green-600 bg-green-50';
                h += `<th class="p-2 border-b border-r ${color} text-center text-xs font-mono">${c}</th>`;
            });
            // Add Item Columns if Filtered
            const activeItemName = document.getElementById('filterItem') ? document.getElementById('filterItem').value : null;
            if (activeItemName) {
                h += `<th class="p-3 border-b border-r bg-purple-50 text-purple-700 font-bold min-w-[150px] sticky-col z-20" style="left: 200px;">${activeItemName}</th>`;
                h += `<th class="p-3 border-b border-r bg-yellow-50 text-yellow-700 font-bold min-w-[80px]">Qty</th>`;
            }

            h += `</tr>`;
            thead.innerHTML = h;

            // Body
            tbody.innerHTML = filtered.map((row, i) => {
                let r = `<tr class="hover:bg-gray-50 border-b border-gray-100">
                    <td class="p-2 border-r text-center text-xs text-gray-400 font-mono">${row["S.No"] || i + 1}</td>
                    <td class="p-2 border-r font-medium text-gray-700 sticky-col bg-white">${row["Student Name"] || ""}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs">${row["Class"] || ""}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs">${row["Section"] || "-"}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs">${row["Gender"] || ""}</td>
                    <td class="p-2 border-r text-center text-gray-600 text-xs text-mono">${row["Admission No"] || ""}</td>`;

                measureCols.forEach(c => {
                    let val = row[c];
                    if (val === '00' || val === '0') val = '';
                    r += `<td class="p-2 border-r text-center font-mono text-gray-600 text-sm">${val}</td>`;
                });
                if (activeItemName) {
                    const item = allItems.find(i => i.name === activeItemName);
                    if (item) {
                        const calcVal = calculateItemValue(row, item);
                        const qty = row[`Qty_${item.name}`] || "";
                        r += `<td class="p-2 border-r text-center text-xs text-purple-700 font-mono bg-purple-50/30 font-bold">${calcVal}</td>`;
                        r += `<td class="p-2 border-r text-center text-sm font-bold text-yellow-700 bg-yellow-50/30">${qty}</td>`;
                    }
                }

                r += `</tr>`;
                return r;
            }).join('');
        }

        function updateCount() {
            const count = getFilteredData().length;
            document.getElementById('rowCount').textContent = count;
            document.getElementById('patternCountDisplay').textContent = count;
        }

        // --- PATTERN LOGIC ---

        function openPatternModal() {
            if (getFilteredData().length === 0) {
                alert("No data to group! Import a file or adjust filters.");
                return;
            }
            document.getElementById('newPatternName').value = `Pattern ${patterns.length + 1}`;
            updateCount();
            document.getElementById('patternModal').classList.remove('hidden');
        }

        async function savePattern() {
            const name = document.getElementById('newPatternName').value;
            const schoolId = document.getElementById('newPatternSchool').value;

            if (!name) return alert("Enter a pattern name");
            if (!schoolId) return alert("Select a school");

            // Ensure filters are mutually synced with DOM inputs
            syncFiltersFromDOM();

            // 1. Capture Data
            const currentFilters = JSON.parse(JSON.stringify(filters));
            const filteredData = getFilteredData();

            // Extract Admission Numbers for Linkage - Robust Cleaning
            const studentAdmissionNos = filteredData
                .map(r => r['Admission No'] || r['Adm No'])
                .filter(x => x)
                .map(x => x.toString().trim()); // Clean Whitespace/Types

            if (studentAdmissionNos.length === 0) return alert("No students found in current filter!");

            // Metadata
            const consumption = document.getElementById('newPatternCons').value || "0";
            const cloth = document.getElementById('newPatternCloth').value || "";
            const req = document.getElementById('newPatternReq').value || "";
            // School Name for Local Display (Hack: Get text from select)
            const sel = document.getElementById('newPatternSchool');
            const schoolName = sel.options[sel.selectedIndex]?.text || "Unknown";

            // 2. Send to Backend
            try {
                const payload = {
                    name,
                    school_id: schoolId,
                    consumption: parseFloat(consumption),
                    cloth_details: cloth,
                    special_req: req,
                    student_admission_nos: studentAdmissionNos,
                    filters: currentFilters // Send Filters!
                };

                const res = await fetch('/api/data/patterns', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.error || "Failed to create pattern");
                }

                const result = await res.json();

                // 3. Local Update (Optimistic/Visual)
                const meta = {
                    school: schoolName,
                    desc: document.getElementById('newPatternDesc').value || "",
                    consumption, cloth, req
                };

                const pattern = {
                    id: result.id || Date.now(),
                    name: name,
                    filters: currentFilters,
                    count: filteredData.length,
                    metadata: meta,
                    schoolId: schoolId // Store internally
                };

                patterns.push(pattern);
                renderModules();
                saveToLocal(); // Save pattern list locally for caching?
                // Ideally we should re-fetch from server, but for now hybrid is fine.

                document.getElementById('patternModal').classList.add('hidden');

                let msg = `Pattern Created! Linked ${result.students_updated} students.`;
                if (result.students_updated === 0) {
                    msg += "\n\n⚠️ Warning: No students were linked in the system.\nPlease ensure these students are uploaded to the Cloud via the Planet Editor first.";
                }
                alert(msg);

            } catch (e) {
                console.error(e);
                alert("Error creating pattern: " + e.message);
            }
        }

        function updatePattern() {
            if (!loadedPatternId) return;
            const pIndex = patterns.findIndex(p => p.id === loadedPatternId);
            if (pIndex === -1) return;

            if (confirm(`Update pattern "${patterns[pIndex].name}" with current filters?`)) {
                patterns[pIndex].filters = JSON.parse(JSON.stringify(filters));
                patterns[pIndex].count = getFilteredData().length;
                renderModules();
                saveToLocal();
                alert("Pattern updated successfully!");
            }
        }

        function renderModules() {
            const container = document.getElementById('patternList');
            if (patterns.length === 0) {
                container.innerHTML = '<span class="text-xs text-gray-400 italic py-1">No patterns created yet.</span>';
                return;
            }

            container.innerHTML = patterns.map(p => `
                <div class="flex items-center gap-2 bg-white border border-gray-200 rounded-md px-3 py-1 text-sm shadow-sm group">
                    <button onclick="loadPattern(${p.id})" class="text-blue-600 font-bold hover:underline" title="Load Filters">${p.name}</button>
                    <span class="text-xs text-gray-400 font-mono">(${p.count !== undefined ? p.count : (p.student_admission_nos ? p.student_admission_nos.length : '?')})</span>
                    <button onclick="openExportForPattern(${p.id})" class="text-gray-400 hover:text-green-600 ml-1" title="Export Pattern">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    </button>
                    <button onclick="deletePattern(${p.id})" class="text-gray-300 hover:text-red-500 ml-1 opacity-0 group-hover:opacity-100 transition-opacity">×</button>
                </div>
            `).join('');
        }

        function loadPattern(id) {
            const p = patterns.find(x => x.id === id);
            if (!p) return;

            filters = JSON.parse(JSON.stringify(p.filters));

            // Restore Inputs
            document.getElementById('searchInput').value = filters.search || "";
            document.getElementById('filterClass').value = filters.class || "";
            document.getElementById('filterSection').value = filters.section || "";
            document.getElementById('filterHouse').value = filters.house || "";
            document.getElementById('filterGender').value = filters.gender || "";

            // Restore Item Filters & Datalists
            document.getElementById('filterItem').value = filters.item;

            // BACKUP COMPONENTS: handleItemFilter() will reset filters.components to {}
            // We must save them to restore them after the DOM inputs are created.
            const savedComponents = JSON.parse(JSON.stringify(filters.components || {}));

            // Re-trigger item filter rendering to show dyanmic controls
            handleItemFilter();

            // RESTORE COMPONENTS: Put them back into state and DOM
            filters.components = savedComponents;

            // Now restore the dynamic component values
            const container = document.getElementById('dynamicFilters');
            if (filters.components) {
                Array.from(container.children).forEach(wrapper => {
                    const input = wrapper.querySelector('input');
                    if (input && filters.components[input.placeholder]) {
                        input.value = filters.components[input.placeholder];
                    }
                });
            }

            renderTable();
            updateCount();
            alert(`Loaded pattern: ${p.name}`);

            // Enter "Update Mode"
            loadedPatternId = p.id;
            document.getElementById('btnCreatePattern').classList.add('hidden');
            document.getElementById('btnUpdatePattern').classList.remove('hidden');
        }

        function resetView() {
            // Clear Filters
            document.getElementById('searchInput').value = '';
            document.getElementById('filterClass').value = '';
            document.getElementById('filterSection').value = '';
            document.getElementById('filterHouse').value = '';
            document.getElementById('filterGender').value = '';
            document.getElementById('filterItem').value = '';

            // Clear internal state
            filters = { search: '', class: '', section: '', house: '', gender: '', item: '', components: {} };

            // Re-render
            handleItemFilter(); // Clears dynamic
            // handleFilter() called internally? no, manual reset
            renderTable();
            updateCount();

            // Reset Mode
            loadedPatternId = null;
            document.getElementById('btnCreatePattern').classList.remove('hidden');
            document.getElementById('btnUpdatePattern').classList.add('hidden');
        }

        function deletePattern(id) {
            if (confirm("Remove this pattern group?")) {
                patterns = patterns.filter(p => p.id !== id);
                renderModules();
                saveToLocal(); // Update storage
            }
        }

        // --- EXPORT LOGIC ---

        let currentExportPatternId = null;

        function openExportForPattern(id) {
            currentExportPatternId = id;
            const p = patterns.find(x => x.id === id);

            document.getElementById('metaPattern').value = p.name;
            document.getElementById('exportFilters').textContent = p.name;

            // Restore Metadata for Export Modal
            if (p.metadata) {
                document.getElementById('metaSchool').value = p.metadata.school || "";
                document.getElementById('metaDesc').value = p.metadata.desc || "";
                document.getElementById('metaConsumption').value = p.metadata.consumption || "";
                document.getElementById('metaClothDetails').value = p.metadata.cloth || "";
                document.getElementById('metaSpecialReq').value = p.metadata.req || "";
            }

            // Must Ensure Data is Correct (Reload Filters quietly)
            // Must Ensure Data is Correct (Reload Filters quietly)
            // This ensures getFilteredData() uses this pattern's filters
            loadPattern(id);
            // Force re-render just to be safe, though loadPattern does it
            renderTable();

            document.getElementById('exportModal').classList.remove('hidden');
            updateExportTotal();
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.add('hidden');
        }

        function updateExportTotal() {
            const consumption = parseFloat(document.getElementById('metaConsumption').value) || 0;
            const filtered = getFilteredData();
            // Count "Active" Students: For simplistic grouping, every row is a student.
            const total = (filtered.length * consumption).toFixed(2);
            document.getElementById('exportTotalCloth').textContent = `${total} M`;
        }

        async function confirmExportPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape' });

            // Metadata Block
            const school = document.getElementById('metaSchool').value;
            const code = document.getElementById('metaPattern').value;
            const desc = document.getElementById('metaDesc').value;
            const cloth = document.getElementById('metaClothDetails').value;
            const req = document.getElementById('metaSpecialReq').value;
            const totalCloth = document.getElementById('exportTotalCloth').textContent;

            let y = 15;
            doc.setFontSize(14); doc.text(`Pattern List`, 14, y); y += 8;
            doc.setFontSize(12); doc.text(`Pattern Code: ${code}`, 14, y); y += 6;
            doc.setFontSize(10);
            if (school) { doc.text(`School: ${school}`, 14, y); y += 6; }
            if (desc) { doc.text(`Desc: ${desc}`, 14, y); y += 6; }
            if (cloth) { doc.text(`Cloth: ${cloth}`, 14, y); y += 6; }

            if (req) { doc.text(`Special: ${req}`, 14, y); y += 6; }

            // Construct Specifications
            let specs = [];
            if (filters.class) specs.push(`Class: ${filters.class}`);
            if (filters.section) specs.push(`Sec: ${filters.section}`);
            if (filters.house) specs.push(`House: ${filters.house}`);
            if (filters.gender) specs.push(`Gender: ${filters.gender}`);
            if (filters.item) specs.push(`Item: ${filters.item}`);
            if (filters.components) {
                for (const [key, val] of Object.entries(filters.components)) {
                    if (val) specs.push(`${key}: ${val}`);
                }
            }
            if (specs.length > 0) {
                doc.text(`Specs: ${specs.join(', ')}`, 14, y); y += 6;
            }

            doc.text(`Total Qty: ${getFilteredData().length} Students | Total Cloth: ${totalCloth}`, 14, y); y += 10;

            // Determine Cols
            const activeItemName = filters.item;
            const itemHeaders = activeItemName ? [activeItemName, "Qty"] : [];

            const rows = getFilteredData().map(r => {
                const base = [
                    r['Roll No'],
                    r['Student Name'],
                    r['Admission No'] || r['Adm No'] || "",
                    r['House'] || "",
                    r['Class'],
                    r['Section'],
                    ...measureCols.map(m => r[m])
                ];
                if (activeItemName) {
                    const item = allItems.find(i => i.name === activeItemName);
                    if (item) {
                        base.push(calculateItemValue(r, item));
                        base.push(r[`Qty_${item.name}`] || "");
                    }
                }
                return base;
            });

            doc.autoTable({
                head: [['Roll', 'Name', 'Adm No', 'House', 'Class', 'Sec', ...measureCols, ...itemHeaders]],
                body: rows,
                startY: y,
                styles: { fontSize: 8, cellPadding: 2 }
            });
            doc.save(`Pattern_${code}.pdf`);
            closeExportModal();
        }

        function confirmExport() {
            const wb = XLSX.utils.book_new();
            const filtered = getFilteredData();

            // Prefer metadata from storage if available (when exporting via button), else from modal inputs?
            // Actually, openExportForPattern loads inputs, so inputs are source of truth for THIS export.
            const school = document.getElementById('metaSchool').value;
            const code = document.getElementById('metaPattern').value;
            const desc = document.getElementById('metaDesc').value;
            const cloth = document.getElementById('metaClothDetails').value;
            const req = document.getElementById('metaSpecialReq').value;
            const totalCloth = document.getElementById('exportTotalCloth').textContent;

            const activeItemName = filters.item;
            const itemHeaders = activeItemName ? [activeItemName, "Quantity"] : [];

            // Construct Specifications for Excel
            let specs = [];
            if (filters.class) specs.push(`Class: ${filters.class}`);
            if (filters.section) specs.push(`Sec: ${filters.section}`);
            if (filters.house) specs.push(`House: ${filters.house}`);
            if (filters.gender) specs.push(`Gender: ${filters.gender}`);
            if (filters.item) specs.push(`Item: ${filters.item}`);
            if (filters.components) {
                for (const [key, val] of Object.entries(filters.components)) {
                    if (val) specs.push(`${key}: ${val}`);
                }
            }

            // ... (Rest of export logic same)
            // ... (Rest of export logic same)
            const wsData = [
                ["PATTERN LIST EXPORT"],
                ["Pattern Code", code],
                ["School Name", school],
                ["Description", desc],
                ["Cloth Details", cloth],
                ["Special Requirements", req],
                ["Pattern Specifications", specs.join(', ')],
                ["Total Cloth Needed", totalCloth],
                ["Total Students", filtered.length],
                [],
                ["Roll No", "Student Name", "Admission No", "House", "Class", "Section", "Gender", ...measureCols, ...itemHeaders]
            ];

            filtered.forEach(r => {
                const rowArr = [
                    r['Roll No'],
                    r['Student Name'],
                    r['Admission No'] || r['Adm No'] || "",
                    r['House'] || "",
                    r['Class'],
                    r['Section'],
                    r['Gender'],
                    ...measureCols.map(m => r[m])
                ];
                if (activeItemName) {
                    const item = allItems.find(i => i.name === activeItemName);
                    if (item) {
                        rowArr.push(calculateItemValue(r, item));
                        rowArr.push(r[`Qty_${item.name}`] || "");
                    }
                }
                wsData.push(rowArr);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, "Pattern");
            XLSX.writeFile(wb, `Pattern_${code}.xlsx`);
            closeExportModal();
        }



        function calculatePatternQty(p) {
            // Helper to calculate total QTY for a pattern (Sum of item quantities)
            // Robust Approach: Temporarily swap global filters to reuse getFilteredData logic
            const backupFilters = filters; // Save current global state
            try {
                // Use pattern's filters (Deep copy to be safe, though not strictly required if read-only)
                filters = p.filters;

                const rows = getFilteredData();

                // 2. Sum Quantity
                let totalQty = 0;
                const item = allItems.find(i => i.name === p.filters.item);

                rows.forEach(r => {
                    let q = 1; // Default to 1 if not specified
                    if (item) {
                        const val = r[`Qty_${item.name}`];
                        // Precise check to allow 0
                        if (val !== undefined && val !== null && val !== "") {
                            const parsed = parseInt(val);
                            q = isNaN(parsed) ? 1 : parsed;
                        }
                    }
                    totalQty += q;
                });
                return totalQty;
            } finally {
                // Always restore global state
                filters = backupFilters;
            }
        }

        // --- TRASH SYSTEM ---
        let trashPatterns = [];
        const TRASH_STORAGE_KEY = 'exal_trash_patterns';

        function loadTrash() {
            try {
                const stored = localStorage.getItem(TRASH_STORAGE_KEY);
                if (stored) trashPatterns = JSON.parse(stored);
            } catch (e) { console.error("Trash load error", e); }
            updateTrashCount();
        }

        function updateTrashCount() {
            const el = document.getElementById('trashCount');
            if (el) el.textContent = trashPatterns.length;
        }

        function saveTrash() {
            localStorage.setItem(TRASH_STORAGE_KEY, JSON.stringify(trashPatterns));
            updateTrashCount();
        }

        function deletePattern(id) {
            // Find by ID now, not index
            const index = patterns.findIndex(p => p.id === id);
            if (index === -1) return;

            if (!confirm("Move pattern to Trash?")) return;
            const p = patterns[index];
            trashPatterns.push(p);
            patterns.splice(index, 1);
            saveToLocal();
            saveTrash();
            renderModules(); // Re-render list
        }

        function openTrashModal() {
            const modal = document.getElementById('trashModal');
            const list = document.getElementById('trashList');
            const msg = document.getElementById('emptyTrashMsg');

            list.innerHTML = '';
            if (trashPatterns.length === 0) {
                msg.classList.remove('hidden');
            } else {
                msg.classList.add('hidden');
                trashPatterns.forEach((p, i) => {
                    const div = document.createElement('div');
                    div.className = "flex items-center justify-between p-3 bg-white hover:bg-gray-50 group border-b border-gray-100 last:border-0";
                    div.innerHTML = `
                        <div class="flex flex-col">
                            <span class="font-bold text-gray-700 text-sm">${p.name}</span>
                            <span class="text-xs text-gray-400">Items: ${p.count || 0}</span>
                        </div>
                        <div class="flex items-center gap-2">
                             <button onclick="restorePattern(${i})" title="Restore" class="text-green-500 hover:text-green-700 p-1.5 rounded bg-green-50 hover:bg-green-100 transition-colors">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>
                            </button>
                             <button onclick="permanentDelete(${i})" title="Delete Forever" class="text-red-400 hover:text-red-700 p-1.5 rounded bg-red-50 hover:bg-red-100 transition-colors">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"></path></svg>
                            </button>
                        </div>
                    `;
                    list.appendChild(div);
                });
            }
            modal.classList.remove('hidden');
        }

        function closeTrashModal() {
            document.getElementById('trashModal').classList.add('hidden');
        }

        function restorePattern(i) {
            const p = trashPatterns[i];
            patterns.push(p);
            trashPatterns.splice(i, 1);
            saveToLocal();
            saveTrash();
            renderModules();
            openTrashModal(); // Refresh modal
        }

        function permanentDelete(i) {
            if (!confirm("Delete forever? This logic cannot be undone.")) return;
            trashPatterns.splice(i, 1);
            saveTrash();
            openTrashModal();
        }

        function emptyTrash() {
            if (!confirm(`Empty Trash? All ${trashPatterns.length} patterns will be lost forever.`)) return;
            trashPatterns = [];
            saveTrash();
            openTrashModal();
        }

        // --- PACKING LIST EXPORT ---

        function getPackingListData() {
            // Aggregate all students from all patterns
            let allRows = [];
            const backupFilters = filters; // Backup global state

            try {
                patterns.forEach(p => {
                    // Temporarily Apply Filters
                    filters = p.filters;
                    const pRows = getFilteredData();
                    const item = allItems.find(i => i.name === p.filters.item);

                    pRows.forEach(r => {
                        let qty = 1;
                        if (item && r[`Qty_${item.name}`]) {
                            const q = parseInt(r[`Qty_${item.name}`]);
                            if (!isNaN(q)) qty = q;
                        }

                        // Create Simplified Row
                        allRows.push({
                            "Student Name": r["Student Name"],
                            "School": p.metadata?.school || "",
                            "Class": r["Class"],
                            "Section": r["Section"],
                            "Pattern Name": p.name,
                            "Gender": r["Gender"],
                            "House": r["House"] || "",
                            "Description": p.metadata?.desc || "",
                            "Quantity": qty,
                            // New Fields
                            "Roll No": r["Roll No"] || "",
                            "Admission No": r["Admission No"] || r["Adm No"] || "",
                            // Internal sort keys
                            _clsRank: getClassRank(r["Class"]),
                            _sec: r["Section"],
                            _name: r["Student Name"]
                        });
                    });
                });
            } finally {
                filters = backupFilters; // Restore
            }

            // Sort by Class -> Section -> Name
            allRows.sort((a, b) => {
                if (a._clsRank !== b._clsRank) return a._clsRank - b._clsRank;
                if (a._sec !== b._sec) return a._sec.localeCompare(b._sec);
                return a._name.localeCompare(b._name);
            });

            return allRows;
        }

        function exportPackingListExcel() {
            if (patterns.length === 0) return alert("No patterns to export.");

            const rows = getPackingListData();
            const wb = XLSX.utils.book_new();
            const wsData = [
                ["PACKING LIST REPORT"],
                [`Generated: ${new Date().toLocaleDateString()}`],
                [],
                ["Roll No", "Admission No", "Student Name", "School", "Class", "Section", "Pattern Name", "Gender", "House", "Description", "Quantity"]
            ];

            rows.forEach(r => {
                wsData.push([
                    r["Roll No"],
                    r["Admission No"],
                    r["Student Name"],
                    r["School"],
                    r["Class"],
                    r["Section"],
                    r["Pattern Name"],
                    r["Gender"],
                    r["House"],
                    r["Description"],
                    r["Quantity"]
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            // Widths
            ws['!cols'] = [{ wch: 10 }, { wch: 15 }, { wch: 25 }, { wch: 20 }, { wch: 10 }, { wch: 10 }, { wch: 25 }, { wch: 10 }, { wch: 15 }, { wch: 20 }, { wch: 10 }];

            XLSX.utils.book_append_sheet(wb, ws, "Packing List");
            XLSX.writeFile(wb, "Packing_List.xlsx");
        }

        async function exportPackingListPDF() {
            if (patterns.length === 0) return alert("No patterns to export.");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape' });
            const rows = getPackingListData();

            doc.setFontSize(16);
            doc.text("Packing List Report", 14, 15);
            doc.setFontSize(10);
            doc.text(`Generated: ${new Date().toLocaleDateString()} | Total Items: ${rows.length}`, 14, 22);

            const tableRows = rows.map(r => [
                r["Roll No"],
                r["Admission No"],
                r["Student Name"],
                r["School"],
                r["Class"],
                r["Section"],
                r["Pattern Name"],
                r["Gender"],
                // r["House"], // Optional: Hide House if space is tight, or keep it
                // r["Description"], // Keep essential fields
                r["Quantity"]
            ]);

            doc.autoTable({
                head: [["Roll", "Adm No", "Name", "School", "Class", "Sec", "Pattern", "Gen", "Qty"]],
                body: tableRows,
                startY: 28,
                styles: { fontSize: 9 },
                headStyles: { fillColor: [44, 62, 80] }
            });

            doc.save("Packing_List.pdf");
        }

        function exportAllPatternsSummary() {
            if (patterns.length === 0) return alert("No patterns to export.");

            const wb = XLSX.utils.book_new();
            const wsData = [
                ["Pattern Name", "School", "Description", "Cloth Details", "Special Req", "Item Type", "M/Size of Pattern", "Cutting Quantity", "Total Cloth (M)", "Pattern Specifications"]
            ];

            patterns.forEach(p => {
                const m = p.metadata || {};
                // Calculate correct quantity on the fly
                const correctQty = calculatePatternQty(p);
                // Update p.count for consistency (optional)
                p.count = correctQty;

                const cons = parseFloat(m.consumption) || 0;
                const totalCloth = (cons * correctQty).toFixed(2);

                // Construct filter summary
                let specifications = [];
                if (p.filters.class) specifications.push(`Class: ${p.filters.class}`);
                if (p.filters.section) specifications.push(`Sec: ${p.filters.section}`);
                if (p.filters.house) specifications.push(`House: ${p.filters.house}`);
                if (p.filters.gender) specifications.push(`Gender: ${p.filters.gender}`);
                if (p.filters.item) specifications.push(`Item: ${p.filters.item}`);
                // Add Measurement Filters
                if (p.filters.components) {
                    for (const [key, val] of Object.entries(p.filters.components)) {
                        if (val) specifications.push(`${key}: ${val}`);
                    }
                }

                wsData.push([
                    p.name,
                    m.school || "",
                    m.desc || "",
                    m.cloth || "",
                    m.req || "",
                    p.filters.item || "Mixed",
                    cons,
                    correctQty,
                    totalCloth,
                    specifications.join(', ')
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            // Auto-width
            const wscols = wsData[0].map(() => ({ wch: 20 }));
            ws['!cols'] = wscols;

            XLSX.utils.book_append_sheet(wb, ws, "All Patterns Summary");
            XLSX.writeFile(wb, "All_Patterns_Summary.xlsx");
        }

        function exportAllPatternsSummaryPDF() {
            if (patterns.length === 0) return alert("No patterns to export.");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape' });

            doc.setFontSize(16);
            doc.text("All Patterns Summary", 14, 15);
            doc.setFontSize(10);
            doc.text(`Generated: ${new Date().toLocaleDateString()}`, 14, 22);

            const headers = [["Pattern Name", "School", "Desc", "Cloth Details", "Special Req", "M/Size of Pattern", "Cutting Quantity", "Total Cloth (M)", "Pattern Specifications"]];
            const rows = patterns.map(p => {
                const m = p.metadata || {};
                const correctQty = calculatePatternQty(p); // Use helper

                const cons = parseFloat(m.consumption) || 0;
                const totalCloth = (cons * correctQty).toFixed(2);

                // Construct a summary of filters for the "Pattern Specifications" column
                let specifications = [];
                if (p.filters.class) specifications.push(`Class: ${p.filters.class}`);
                if (p.filters.section) specifications.push(`Sec: ${p.filters.section}`);
                if (p.filters.house) specifications.push(`House: ${p.filters.house}`);
                if (p.filters.gender) specifications.push(`Gender: ${p.filters.gender}`);
                if (p.filters.item) specifications.push(`${p.filters.item}`);
                // Add Measurement Filters
                if (p.filters.components) {
                    for (const [key, val] of Object.entries(p.filters.components)) {
                        if (val) specifications.push(`${key}: ${val}`);
                    }
                }

                return [
                    p.name,
                    m.school || "-",
                    m.desc || "-",
                    m.cloth || "-",
                    m.req || "-",
                    cons.toFixed(2),
                    correctQty,
                    totalCloth,
                    specifications.join(', ')
                ];
            });

            doc.autoTable({
                head: headers,
                body: rows,
                startY: 25,
                styles: { fontSize: 9 },
                headStyles: { fillColor: [44, 62, 80] }
            });

            doc.save("All_Patterns_Summary.pdf");
        }

    </script>
</body>

</html>